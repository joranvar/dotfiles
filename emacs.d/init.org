#+TITLE: The dotfile root

* Purpose

This file is tangled on Emacs startup, which will result in both more configuration to be loaded by Emacs and dotfiles to serve as configuration for other programs.

* SSH configuration
:PROPERTIES:
:header-args: :tangle ~/.ssh/config :comments noweb :tangle-mode (identity #o400) :mkdirp yes
:END:

** Default options

I want to see a visual key to become familiar with it.

#+BEGIN_SRC conf
  Host *
       VisualHostKey yes
       ControlPath ~/.ssh/controlmasters/%r@%h:%p
       ControlMaster auto
       ControlPersist 10m
#+END_SRC

** Host aliases                                                       :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQgAjd0W9CeBnSVJjR9Fm4acbcM+DklomvBO66pv+yV5H0E7
8DX7BVoMufn2eAUSKaxQI2JIW9Z40SNux02K+FByGLyZgmZVKY8rbneSIB6A84AK
L/2Pak4D6DB+a9rX3+4qxIHNdcAr1mo5qlQnqhFwKXaD+KcMNg5ROgunt3U6A7pf
ZCZEME+BVLfYT7f400KQw1i4MfkXkxr/LX9FeVYoj8haE80pnPtf0UOB4FTA31Yk
EQodrS4fjqridyFu/UYXx+q3sIEStuEFeXwLeU1pektbrA93yWVVuzabwwvJVegq
ovon3EIRvSdDsJg6ARqOOugmjQ/O62smVWMvMkbsDNLAmAGW4V0iJsJ0qFtML4IZ
KydwdUGzqam+O0CMyIuC4nGpjBsMcb58asOZGJ7Qx/9pBYhTyd79RbKOKYespGD5
ktIAl6hX1Dr4wl+k2ohzlhXU1CEAjKflSQQNzeknQ3LfT6v9AjNIDylv5AXOdcur
KwFr4hzY2m/pYVMIGv/3eEohxfduSSjLRwzvDTig/UaAemlcd8p1BTPwVe7nyaAD
0rEXiAbj3YZ5mzL910bAKLL7k/UUd7k5gF+3cWXdzoRxlNHEPshdkjYRIq0caO6h
IugwONG1qwSLKFlwZVqfZdZGIWg29VtBfN8GyvjYYTwEvh2XBhmWUIoWJTn5HTjL
OPVvkorlI6mZcqj2KtSM2fc38jlUzPwLgzwHndIl44hJUM3f0d1uv9+CA+5ecoFE
P9150X7kn2FavsgUHMP/FSyOOiD6ZFL5uq241XfW5Ze+Ef2bcOmfRxLm
=xqLD
-----END PGP MESSAGE-----

* Shell

** What was already there

This part is to replace what was already there, before I started "going literal".

*** Zsh

#+BEGIN_SRC sh :tangle ~/.zshrc :comments noweb :tangle-mode (identity #o444)
  source ~/.antigen/antigen.zsh

  antigen bundle gpg-agent
  antigen bundle git
  antigen bundle zsh-users/zsh-syntax-highlighting
  antigen use oh-my-zsh
  antigen theme candy
  antigen bundle spwhitt/nix-zsh-completions
  antigen bundle zsh-users/zsh-completions src
  antigen apply

  function weather() {curl wttr.in/$1 -f --stderr /dev/null | head -n 7;}

  export PATH=$PATH:/home/joranvar/.local/bin
#+END_SRC

*** Xprofile

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444) :shebang #!/usr/bin/env zsh
  gpg-connect-agent /bye
  GPG_TTY=$(tty)
  export GPG_TTY
  export SSH_AUTH_SOCK="/var/run/user/1000/gnupg/S.gpg-agent.ssh"

  unset SSH_AGENT_PID
#+END_SRC

** Host aliases                                                       :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQf9Gi+qkyD9hGPq+4fnGu5ZLPGhESwIdGlvkpLw7BzMpSm3
lQ/VaAcZ2C+NkzaB7iXfyx5VkHlaxhGelBxT9N36dcNrLRFXTZP9axOqt5xzq2OD
7yEi0CdtEQ+KKzQTF384Xm4FsOR8Ab2wIKnvLSNuO60T2oPuPWVoJ5TuACnfPjGj
J/IQ9KiJ43960gklzDlslb8n0hm4YVK7CK6hZuorSr+sxuAyjm0t5f1zVEhSJNKz
ZmD7UzfVCyJfDZTXIbJH89+Ik3Jt0g0YzXC1y703wGz1yxzXHwOSc0sonrNVlzxY
GSAB7Om/u0d3q7UeNatR1sr1sDMCDFCqjbo3NFcod9LAWgHYRchRyGRiYguHT73M
rhImXAujntte0LOOalIXcMnanIuZohhizmirEJrFCU6hx/iubYf1l4C2kjzEfwnQ
DiJwQSs9AEZLNF/xPXHcmKjME1+T5cz0sjd1GgY+0WhS03QIGnBouhPE78+5DD+r
Nwsvg0O0h54OhVmQaxSPUEkSuy5A5OjptIfcRTGhFMaVbvbVAmVcIcWvWJOFXuq4
q2+KwxXZd9Kx1hrJQQDBUy6jhq4GwFmME1pXCx0jdzGRmvKetBfLYcexCBufBtNw
IV22LMkkK5nTZAcZN4bSYxyx7Kp7kjKjyiyy9yCkfbfnx4/3OyuQjTwKFcle64jN
xC1wY2PMiHGwxxsKJlwXu5OzK7/Gq6E8nBCF5A==
=4Ab7
-----END PGP MESSAGE-----

** Command aliases

These snippets can be quite useful, sometimes.

#+BEGIN_SRC sh :tangle ~/.zshrc :comments noweb :tangle-mode (identity #o444)
  timer () { timeout $1 zsh -c "(for i in \$(seq 1 999999); do echo -ne \\\\r$1: \$i; sleep 1; done)"; echo }
#+END_SRC

* Emacs configuration
:PROPERTIES:
:header-args: :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
:END:

** Package preparation

*** Package sources 
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

  (setq package-archives '(("gnu"          . "http://elpa.gnu.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")
                           ("melpa"        . "http://melpa.org/packages/")
                           ("org"          . "http://orgmode.org/elpa/")))

  (package-initialize)
#+END_SRC

*** ~use-package~

Then, we'll use ~use-package~ to install and configure all others.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

Ensure that a package is installed by default (why would I enter it otherwise?)

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

*** ~paradox~

Finally, we'll switch to using paradox, for its async execution and automatic updating functionalities.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :config
    (progn
      (setq paradox-execute-asynchronously t)
      (paradox-enable)
      (paradox-refresh-upgradeable-packages)))
#+END_SRC

** Custom settings

They should not be set in the generated ~init.org.el~, but sometimes I want to see what a customization does.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file) (load custom-file))
#+END_SRC

** Basic utils

~dash.el~, ~f.el~ and ~s.el~ cannot be omitted, as they provide very useful tools for emacs-lisp programming.

#+BEGIN_SRC emacs-lisp
  (use-package dash)
  (use-package s)
  (use-package f)
#+END_SRC

*** Async

Add some asyncness, for the sake of less waiting time.

#+BEGIN_SRC emacs-lisp
  (use-package async)
#+END_SRC

** Basic text editing

*** Whitespace pet peeves

Do, please do, remove whitespace from the end of lines, before saving my buffers.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode
    :diminish whitespace-mode global-whitespace-mode
    :config (progn
              (setq-default whitespace-style '(face spaces tabs newline
                                                    space-mark tab-mark
                                                    newline-mark
                                                    trailing lines-tail empty
                                                    indentation::space
                                                    space-after-tab::space)
                            whitespace-line-column 160
                            indent-tabs-mode nil
                            require-final-newline t)
              (defadvice align-regexp (around align-regexp-with-spaces activate)
                (let ((indent-tabs-mode nil))
                  ad-do-it))
              (setq-default tab-width 2)
              (global-whitespace-mode)
              (global-whitespace-cleanup-mode)))
#+END_SRC

*** Search and replace

Search and replace with regexes by default, and show me what you're about to do.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :bind* (("C-c r" . anzu-query-replace-regexp)
           ("C-c C-r" . anzu-replace-at-cursor-thing)
           ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp))
    :diminish anzu-mode
    :config (progn
              (global-anzu-mode)
              (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
              (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp)))
#+END_SRC

*** Selecting stuff

Use expand-region to conveniently select more of the current surroundings.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

*** Markdown formatting

The mode itself.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

Previewing changes on the fly.

#+BEGIN_SRC emacs-lisp
  (use-package flymd
    :commands flymd-flyit)
#+END_SRC

** Start Emacs as a server

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config (progn
              (unless (server-running-p) (server-start))))
#+END_SRC

** Menus and discovery

*** ~helm~

I've used ~helm~ for quite some time now, and I like the way it works.  Therefore, it's the default menu for everything now.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-mini))
    :diminish helm-mode
    :init (progn
            (require 'helm-config)
            (helm-mode 1)
            (helm-autoresize-mode t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))
#+END_SRC

** Projects

Each project is either a version controlled (~magit~!) directory, or some directory I want to be able to browse at once (local repos of files, e.g. videos or pictures).

*** Version control

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-git-repo-p
               magit-status-internal)
    :bind (("C-c g" . magit-status))
    :config
    (setq magit-commit-arguments (if (eq system-type 'gnu/linux)
                                     (list (s-concat "--gpg-sign=" org-crypt-key))
                                   '(""))
          magit-diff-arguments '("--ignore-space-change"
                                 "--ignore-all-space"
                                 "--no-ext-diff"
                                 "-M"
                                 "-C")
          magit-log-arguments '("--graph"
                                "--color"
                                "--decorate"
                                "--show-signature"
                                "-n256")
          magit-merge-arguments '("--no-ff")
          magit-rebase-arguments '("--autostash")
          magit-diff-refine-hunk 'all
          ediff-window-setup-function #'ediff-setup-windows-plain)
    (use-package git-timemachine)
    (when (eq system-type 'windows-nt)
      (setq magit-git-executable "c:/Program Files/Git/bin/git.exe")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :config (progn
              (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
              (global-diff-hl-mode)))
#+END_SRC

*** Navigation

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind (("M-P" . helm-projectile))
    :diminish projectile-mode
    :config (progn
              (projectile-global-mode)
              (setq projectile-indexing-method 'alien
                    projectile-completion-system 'helm
                    ;; projectile-enable-caching t ;; This messes up tramp-sudo, see https://github.com/bbatsov/projectile/issues/835
                    projectile-enable-idle-timer t)
              (use-package helm-ag)
              (use-package helm-projectile
                :config (progn
                          (helm-projectile-on)))
              (use-package neotree
                :config (progn
                          (setq neo-smart-open t)
                          (setq neo-theme 'icons)
                          (setq projectile-switch-project-action (lambda ()
                                                                   (if (magit-git-repo-p (projectile-project-root))
                                                                       (magit-status-internal (projectile-project-root))
                                                                     (dired (projectile-project-root)))
                                                                   ;; (neotree-projectile-action)
                                                                   ))))
              (setq magit-repository-directories (mapcar (lambda (dir)
                                                           (substring dir 0 -1))
                                                         (-filter (lambda (project)
                                                                    (file-directory-p (concat project "/.git/")))
                                                                  (projectile-relevant-known-projects)))
                    magit-repository-directories-depth 1)))
#+END_SRC

** Completion

*** ~company~

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :config (progn
              (global-company-mode)
              (setq company-idle-delay 0.1)))
#+END_SRC

** Programming

*** General stuff

I use flycheck for almost any buffer that can be checked, so enable it everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config (progn
              (global-flycheck-mode)
              (add-to-list 'display-buffer-alist
                           `(,(rx bos "*Flycheck errors*" eos)
                             (display-buffer-reuse-window
                              display-buffer-in-side-window)
                             (reusable-frames . visible)
                             (side            . bottom)
                             (window-height   . 10)))))
#+END_SRC

I like my parentheses balanced, thank you!

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config (progn
              (require 'smartparens-config)
              (show-smartparens-global-mode)
              (smartparens-global-strict-mode)
              (sp-use-paredit-bindings)))
#+END_SRC

Also, please indent my code smartly (except for in F#, it does not play nice there)!

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config (progn
              (global-aggressive-indent-mode)
              (add-to-list 'aggressive-indent-excluded-modes 'org-mode)))
#+END_SRC

*** F#

In F#, I'd like to set the following settings:

#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode
    :config (progn
              (setq fsharp-indent-offset 2)
              (add-to-list 'aggressive-indent-excluded-modes 'fsharp-mode)))
#+END_SRC

*** C#

In C#, the following:

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :config (progn
              (setq csharp-indent-offset 4)))
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :config (progn
              (require 'haskell-indentation)
              (use-package hlint-refactor
                :config (add-hook 'haskell-mode-hook 'hlint-refactor-mode))
              (use-package company-ghc
                :config (add-to-list 'company-backends 'company-ghc))
              (setq company-ghc-show-info t)
              (add-to-list 'aggressive-indent-excluded-modes 'haskell-mode)))
#+END_SRC

In Haskell, use `dante`.

#+BEGIN_SRC emacs-lisp
  (use-package dante
    :commands 'dante-mode
    :init (progn
            (add-hook 'haskell-mode-hook 'dante-mode)))
#+END_SRC

*** Yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'"
    :config (add-to-list 'aggressive-indent-excluded-modes 'yaml-mode))
#+END_SRC

*** PowerShell

#+BEGIN_SRC emacs-lisp
  (use-package powershell
    :mode "\\.ps\\'")
#+END_SRC

*** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :config (add-to-list 'aggressive-indent-excluded-modes 'nix-mode))
  (use-package company-nixos-options
    :config (progn (add-to-list 'company-backends 'company-nixos-options)))
#+END_SRC

*** ELisp

#+BEGIN_SRC emacs-lisp
  (use-package ipretty
    :config (progn (ipretty-mode)))
#+END_SRC

** Mail configuration

I used to check mail with Gnus, directly from the imap-server (in the Exchange case, from davmail), but the Gnus/davmail combination is quite slow, and when checking mail, freezes Emacs a bit.
After reading http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/, I decided to setup a different configuration, and use offlineimap.
Reading https://nakkaya.com/2010/04/10/using-offlineimap-with-gnus/ after that, I decided to skip the mu4e, and use the nnmaildir backend in Gnus.
This backend, however, needs a script to be run for syncing the flags with a "regular" Maildir backend.

*** Flag syncing script
:PROPERTIES:
:header-args: :tangle ~/sync_nnmaildir :comments noweb :tangle-mode (identity #o555) :shebang "#!/usr/bin/env perl"
:END:

This script was downloaded (and adjusted a tiny bit) from http://groups.google.com/group/linux.debian.user/msg/7594165a2b6d1c49.

#+BEGIN_SRC perl
  # Maildir flags are:
  #         D (draft)
  #         F (flagged)
  #         R (replied)
  #         S (seen)
  #         T (trashed)
  # and must occur in ASCII order.
  #
  # flagmatchre = re.compile(':.*2,([A-Z]+)')
  #
  # filename:2,F   => .nnmaildir/marks/tick/filename
  # filename:2,R   => .nnmaildir/marks/reply/filename
  # filename:2,S   => .nnmaildir/marks/read/filename

  use strict;
  use File::Basename;
  use Getopt::Long;
  $Getopt::Long::ignorecase = 0;

  my $from_gnus = 0;
  my $from_maildir = 0;
  my $dir = "~/Maildir";
  GetOptions('-g' => \$from_gnus,
             '-m' => \$from_maildir,
             '-d=s' => \$dir);

  if (! ($from_gnus ^ $from_maildir)) {
      die "Usage: sync_nnmaildir -g [-f]\n   or: sync_nnmaildir -m [-v -f]\n";
  }

  for (glob "$dir/*") {
      my $mb = $_;
      mkdir "$mb/.nnmaildir";
      mkdir "$mb/.nnmaildir/marks";

      for (glob "$mb/cur/*") {
          my $file = $_;

          /(.*)\/cur\/(.*?):.*2,(.*)$/;
          my $path = $1;
          my $message = $2;
          my $flags = $3;

          if ($from_maildir) {
              # Sync ticked flags
              if ($flags =~ /F/) {
                  mkdir "$path/.nnmaildir/marks/tick";
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir ticks\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir ticks\n";
              }

              # Sync replied flags
              if ($flags =~ /R/) {
                  mkdir "$path/.nnmaildir/marks/reply";
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir replies\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir replies\n";
              }

              # Sync read flags
              if ($flags =~ /S/) {
                  mkdir "$path/.nnmaildir/marks/read";
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir seen\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir seen\n";
              }
          } elsif ($from_gnus) {
              my $new_flags = '';

              if (-e "$path/.nnmaildir/marks/tick/$message") {
                  $new_flags = $new_flags . 'F';
              }
              if (-e "$path/.nnmaildir/marks/reply/$message") {
                  $new_flags = $new_flags . 'R';
              }
              if (-e "$path/.nnmaildir/marks/read/$message") {
                  $new_flags = $new_flags . 'S';
              }

              if ($new_flags ne $flags) {
                  rename "$file", "$path/cur/$message:2,$new_flags"
                      and print "Marked mail in $mb as $new_flags\n";
              }
          }
      }
  }

#+END_SRC

*** Offline imap
:PROPERTIES:
:header-args: :tangle ~/.offlineimaprc :comments noweb :tangle-mode (identity #o444)
:END:

#+BEGIN_SRC conf
  [general]
  accounts = Gmail, Exchange
  maxsyncaccounts = 2
  pythonfile = ~/.offlineimap.py

  [Account Gmail]
  localrepository = LocalGmail
  remoterepository = RemoteGmail
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g

  [Repository LocalGmail]
  type = Maildir
  localfolders = ~/Maildir/Gmail

  [Repository RemoteGmail]
  type = Gmail
  maxconnections = 2
  remoteuser = bart.post@gmail.com
  remotepasseval = get_password_emacs("gmail", "imaps")
  folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail', '[Gmail]/Important']
  sslcacertfile = /etc/ssl/certs/ca-certificates.crt

  # These are effectively the same as the above
  [Account Exchange]
  localrepository = LocalExchange
  remoterepository = RemoteExchange
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g

  [Repository LocalExchange]
  type = Maildir
  localfolders = ~/Maildir/Exchange

  # This uses davmail
  [Repository RemoteExchange]
  type = IMAP
  maxconnections = 2
  remoteuser = bart.post@cgm.com
  remotehost = localhost
  remotepasseval = get_password_emacs("localhost", "1143")
  remoteport = 1143
  ssl = no
  sync_deletes = no

  sslcacertfile = /etc/ssl/certs/ca-certificates.crt
#+END_SRC

*** Password management with .authinfo.gpg

This python script will be used to get the credentials.

#+BEGIN_SRC python :tangle ~/.offlineimap.py :comments noweb :tangle-mode (identity #o444)
  import subprocess
  def get_output(cmd):
    # Bunch of boilerplate to catch the output of a command:
    pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (output, errout) = pipe.communicate()
    assert pipe.returncode == 0 and not errout
    return output
  def get_password_emacs(host, port):
    cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\")'" % (host,port)
    return get_output(cmd).strip().lstrip('"').rstrip('"')
#+END_SRC

And this is the code that will be used to decrypt the authinfo.

#+BEGIN_SRC emacs-lisp
  (use-package offlineimap
    :config (progn
              (setq auth-sources (list "~/.authinfo.gpg"))
              (defun offlineimap-get-password (host port)
                (let ((netrc (nth 0 (auth-source-search
                                     :host host
                                     :port port))))
                  (when netrc (let ((secret (plist-get netrc :secret)))
                                (if (functionp secret)
                                    (funcall secret)
                                  secret)))))
              (defun offlineimap-get-username (host port)
                (let ((netrc (nth 0 (auth-source-search
                                     :host host
                                     :port port))))
                  (when netrc (let ((user (plist-get netrc :user)))
                                (if (functionp user)
                                    (funcall user)
                                  user)))))))
#+END_SRC

*** Gnus

Gnus will be used to read the mail that was pulled over here.

#+BEGIN_SRC emacs-lisp
  (use-package gnus
    :config (progn
              (setq gnus-select-method '(nnmaildir "GMail"
                                                   (directory "~/Maildir/Gmail")
                                                   (directory-files nnheader-directory-files-safe)
                                                   (get-new-mail nil))
                    gnus-secondary-select-methods '((nnmaildir "Exchange"
                                                               (directory "~/Maildir/Exchange")
                                                               (directory-files nnheader-directory-files-safe)
                                                               (get-new-mail nil)))
                    mm-discouraged-alternatives '("text/html" "text/richtext") ;; Prefer text/plain
                    gnus-decay-scores t
                    gnus-use-adaptive-scoring t)
              (when window-system
                (setq gnus-sum-thread-tree-indent "  ")
                (setq gnus-sum-thread-tree-root "● ")
                (setq gnus-sum-thread-tree-false-root "◯ ")
                (setq gnus-sum-thread-tree-single-indent "◎ ")
                (setq gnus-sum-thread-tree-vertical        "│")
                (setq gnus-sum-thread-tree-leaf-with-other "├─► ")
                (setq gnus-sum-thread-tree-single-leaf     "╰─► "))
              (setq-default gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
                            gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
                            gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
                            gnus-thread-sort-functions '(gnus-thread-sort-by-number (not gnus-thread-sort-by-total-score))
                            gnus-subthread-sort-functions '(gnus-sort-thread-by-number))
              (add-hook 'gnus-group-mode-hook 'gnus-topic-mode) ;; Show me topics
              (add-hook 'gnus-startup-hook (lambda () (gnus-demon-add-handler 'gnus-demon-scan-news 1 t)))))
#+END_SRC

*** notmuch

Notmuch will also be used to read the mail that was pulled over here.  Let's see how it compares to Gnus.

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :bind (("C-c m" . notmuch-hello)))
#+END_SRC

*** GPG for mails

#+BEGIN_SRC emacs-lisp
  (use-package epg
    :config (progn
              (setq mml2015-use 'epg

                    mml2015-verbose t
                    epg-user-id "9BD68A49AB3D8E4D"
                    mml2015-encrypt-to-self t
                    mml2015-always-trust nil
                    mml2015-cache-passphrase t
                    mml2015-passphrase-cache-expiry '36000
                    mml2015-sign-with-sender t

                    gnus-message-replyencrypt t
                    gnus-message-replysign t
                    gnus-message-replysignencrypted t
                    gnus-treat-x-pgp-sig t

                    ;; mm-sign-option 'guided
                    ;; mm-encrypt-option 'guided
                    mm-verify-option 'always
                    mm-decrypt-option 'always
                    gnus-buttonized-mime-types '("multipart/alternative" "multipart/encrypted" "multipart/signed"))
              (add-hook 'gnus-message-setup-hook (lambda () (mml-secure-message-sign)))))
#+END_SRC

*** Sending mail

When sending a mail, it should reflect who I want to send it as (from my work mail, or personal).

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail
    :config (progn
              (require 'message)
              (setq gnus-posting-styles
                    '((".*"
                       (signature "")
                       (address "bart.post@gmail.com")
                       ("X-Message-SMTP-Method" "smtp smtp.gmail.com 587 bart.post@gmail.com")
                       (eval (set (make-local-variable 'message-cite-style) message-cite-style-gmail)))
                      ("Exchange"
                       (signature "")
                       (address "bart.post@cgm.com")
                       ("X-Message-SMTP-Method" "smtp localhost 1025 bart.post@cgm.com")
                       (eval (set (make-local-variable 'message-cite-style) message-cite-style-outlook)))))
              (setq smtpmail-stream-type nil
                    mail-user-agent 'message-user-agent
                    smtpmail-smtp-service 587
                    message-send-mail-function 'smtpmail-send-it
                    smtpmail-default-smtp-server "smtp.gmail.com"
                    send-mail-function 'smtpmail-send-it)))
#+END_SRC

Also, I want to be able to compose mail in org-mode and send it as html.

#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :config (progn
              (add-hook 'message-mode-hook
                        (lambda ()
                          (orgstruct-mode)
                          (local-set-key "\C-co" (lambda ()
                                                    (interactive)
                                                    (save-excursion
                                                      (message-goto-body)
                                                      (when (looking-at "<#secure.*>") (forward-line 1))
                                                      (set-mark-command nil)
                                                      (insert "#+OPTIONS: toc:nil ^:nil\n")
                                                      (goto-char (point-max))
                                                      (org-mime-htmlize nil))))))
              (add-hook 'org-mode-hook
                        (lambda () (local-set-key "\C-co" 'org-mime-org-buffer-htmlize)))))

#+END_SRC

** Browsing

Use conkeror by default.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-generic-program (executable-find "conkeror")
        browse-url-browser-function 'browse-url-generic)
#+END_SRC

Use conkeror-minor-mode.

#+BEGIN_SRC emacs-lisp
  (use-package conkeror-minor-mode
    :config (progn
              (add-to-list 'auto-mode-alist' ("conkerorrc" . js-mode))
              (add-hook 'js-mode-hook (lambda ()
                                        (when (string-match "conkerorrc" (buffer-file-name))
                                          (conkeror-minor-mode))))))
#+END_SRC

Use ~moz-repl~ to communicate with conkeror.

#+BEGIN_SRC emacs-lisp
  (use-package moz
    :commands moz-minor-mode
    :init (progn
              (add-hook 'javascript-mode-hook (lambda () (moz-minor-mode 1)))))
#+END_SRC

** Literate programming

Oh boy, org-babel is so nice!

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config (progn
              (use-package ob-http)
              (org-babel-do-load-languages 'org-babel-load-languages '((sql . t)
                                                                       (shell . t)
                                                                       (http . t)))))
#+END_SRC

When exporting, I want to see pretty source code!

#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

** Agenda management

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
    :bind (("C-c a" . org-agenda)
           ("C-c c" . org-capture))
    :config (progn
              (setq org-use-sub-superscripts '{}
                    org-pretty-entities t
                    org-fontify-emphasized-text t
                    org-adapt-indentation nil
                    org-hide-leading-stars t
                    org-ellipsis "↷"
                    org-catch-invisible-edits 'error
                    org-use-speed-commands t
                    org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)"))
                    org-agenda-span 1
                    org-agenda-skip-scheduled-if-done t
                    org-agenda-skip-timestamp-if-done t
                    org-clock-report-include-clocking-task t
                    org-refile-use-outline-path t
                    org-outline-path-complete-in-steps nil
                    org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t% s")
                                               (timeline . "  % s")
                                               (todo . " %i %-12:c")
                                               (tags . " %i %-12:c")
                                               (search . " %i %-12:c")))
              <<gtd-setup>>
              ))
#+END_SRC

*** My GTD setup

I just based this on https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html, which is really like setups I've used before.

#+NAME: gtd-setup
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-agenda-files '("~/org/inbox.org"
                           "~/org/gtd.org"
                           "~/org/tickler.org")
        org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                             ("~/org/someday.org" :level . 1)
                             ("~/org/tickler.org" :maxlevel . 2))
        org-capture-templates '(("t" "Todo [inbox]" entry
                                 (file+headline "~/org/inbox.org" "INBOX")
                                 "* TODO %i%?\n%U\n%a\n"
                                 :clock-in t :clock-resume t)
                                ("i" "Interrupt" entry
                                 (file+headline "~/org/inbox.org" "Interrupts")
                                 "* %i%? :@interrupt:\n%U\n"
                                 :clock-in t :clock-resume t)
                                ("T" "Tickler" entry
                                 (file+headline "~/org/tickler.org" "Tickler")
                                 "* %i%?\n%^t%a\n"))
        org-agenda-custom-commands '((" " "Default" ((agenda "")
                                                     (todo "" ((org-agenda-overriding-header "INBOX")
                                                               (org-agenda-files '("~/org/inbox.org"))))
                                                     (todo "" ((org-agenda-overriding-header "Next Action")
                                                               (org-agenda-skip-function #'joranvar:org-agenda-skip-all-siblings-but-first)
                                                               (org-agenda-files (remove "~/org/inbox.org" org-agenda-files))
                                                               (org-agenda-prefix-format '((todo . " %-50b %-12:c")))))))
                                     ("o" "At the office" tags-todo "@office"
                                      ((org-agenda-overriding-header "Office")
                                       (org-agenda-skip-function #'joranvar:org-agenda-skip-all-siblings-but-first)))))

  (defun joranvar:org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
#+END_SRC

*** Jira worklog integration

#+BEGIN_SRC emacs-lisp
  (load "/home/joranvar/dotfiles/emacs.d/lisp/org-log-to-jira/org-log-to-jira.el")
#+END_SRC

** Communication

*** IRC

Using RCIRC for IRC makes sense.  I also use it to connect to my team's Slack.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package rcirc
    :config (progn
              (rcirc-track-minor-mode)
<<irc-servers>>
              (add-to-list 'rcirc-markup-text-functions #'rcirc-smileys)))

    (defvar rcirc-smileys '((":)" . "☺")
                            (":(" . "☹")
                            ("<3" . "♥")))

    (defvar rcirc-smiley-regexp
      (regexp-opt (mapcar 'car rcirc-smileys))
      "Regular expression matching the keys in rcirc-smileys.")

    (defun rcirc-smileys (&rest ignore)
      "Use unicode smileys in the buffer"
      (goto-char (point-min))
      (while (re-search-forward rcirc-smiley-regexp nil t)
        (replace-match (cdr (assoc (match-string 0) rcirc-smileys)))))
#+END_SRC

**** IRC servers                                                      :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQgAgcEIJNxDtISxOT9P8h6eZ36qC53Eb42Hh6VmEyY0ODrF
7SEwPC1OCObFHkHcLc9m1n+O1cAeHKqUj7f5DeeGkxpehxvL/43Aalvw4mOPU3yY
VM84SIuOfJgD0ZPBryZYcsOmcYoroH7Yt7ZZ02gvYQ9zqE53Imi291+s96gCbX1u
88w4OW/w3J/KJIbo/9Y0Lh5wn9DbWRpz/7CSmVdR8letQH1gZ1FhZJO8c4b9bpbg
HacZFHFYq/hw9mKGNe1HiDBh8lCPesygGJFBWaMwtXiZEwhQn/+fUzNv0bwq/8Kd
63D3EwKIIaGD+Zx5WzXXVfzwCk/iy/PvoqqRC7oZ6tLAZgH5cWMj0cIhPCDYzKnn
Fn03siQt5yBQYmQrh6XDEymvDK2wu+yBbRmUUXH2YewcMf1XQKzh9EIa7zR2F1zO
wkYlp8hqYsU2PaAsd+RFm1ZhKgLajzrGVwvCVNl9pX6WTb3OJJsyq/W62EBCm4b7
NVq5dgH/AKwUA+6D1J8QSzBINZ14yUxmsn8/Igg4Wh3v7laNKSg7Yk8j6JSySfdV
RYAE0fMsY2bCKuUU8GArdwZlrn9O0zpws2P85Y/8/cZ4VVjGisd9K2SAqbJVEbIE
GIdIhLtWZ+3AaI3J6EOdK09dA4RzrXYW1+w/WD+hpf0RTlqinJSbTrCOcm7kCuFz
r+ZjBSSIqEO5AK+nG3e6F68svpi6A6VCiVquGUA4bpXnKA8h5bXTdA==
=jpgS
-----END PGP MESSAGE-----

** Secrets

Some stuff I want to be kept hidden from others.  Luckily, we have gpg (and org-crypt)

#+BEGIN_SRC emacs-lisp
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  (setq org-crypt-key "AE05B5A8D130BE84B88192809BD68A49AB3D8E4D")
  (advice-add 'org-babel-tangle :around
              (lambda (oldfun &rest args)
                (org-decrypt-entries)
                (remove-hook 'before-save-hook 'org-encrypt-entries t)
                (apply oldfun args)
                (add-hook 'before-save-hook 'org-encrypt-entries nil t)
                (org-encrypt-entries)))
#+END_SRC

* Games

** Nethack

#+BEGIN_SRC conf :tangle ~/.nethackrc :comments noweb :tangle-mode (identity #o400)
  # Compound options
  OPTIONS=role:wizard
  OPTIONS=race:elf
  OPTIONS=align:chaotic
  OPTIONS=gender:male
  #OPTIONS=name:joranvar
  OPTIONS=catname:Fluffy
  OPTIONS=dogname:Bally
  OPTIONS=horsename:Tricksy
  #OPTIONS=pettype:cat
  OPTIONS=autopickup
  # cash, amulets, scrolls, spellbooks, potions, rings, wands
  #* # NOT gems/rocks
  OPTIONS=pickup_types:$"?+!=/
  # Well, this is nice: "

  OPTIONS=autodig
  OPTIONS=autoquiver
  OPTIONS=checkpoint
  OPTIONS=nocmdassist
  OPTIONS=color
  OPTIONS=confirm
  OPTIONS=DECgraphics
  OPTIONS=noeight_bit_tty
  OPTIONS=extmenu
  OPTIONS=fixinv
  OPTIONS=help
  #OPTIONS=hp_monitor
  OPTIONS=hilite_pet
  OPTIONS=noignintr
  OPTIONS=lit_corridor
  OPTIONS=lootabc
  OPTIONS=mail
  OPTIONS=null
  #OPTIONS=noparanoid_hit
  #OPTIONS=noparanoid_quit
  #OPTIONS=paranoid_remove
  OPTIONS=prayconfirm
  OPTIONS=pushweapon
  OPTIONS=norest_on_space
  OPTIONS=safe_pet
  #OPTIONS=showborn
  #OPTIONS=noshowbuc
  OPTIONS=showexp
  OPTIONS=showrace
  OPTIONS=showscore
  OPTIONS=silent
  OPTIONS=sortpack
  OPTIONS=sparkle
  OPTIONS=nostandout
  OPTIONS=time
  OPTIONS=travel
  #OPTIONS=use_darkgray
  OPTIONS=nouse_inverse
  OPTIONS=verbose
  #OPTIONS=win_edge
  # Compound options
  OPTIONS=msghistory:20
  OPTIONS=boulder:0
  OPTIONS=disclose:+i +a +v +g +c
  OPTIONS=fruit:snozberry
  OPTIONS=menustyle:full
  OPTIONS=menu_headings:inverse
  OPTIONS=msg_window:reversed
  OPTIONS=number_pad:1
  OPTIONS=pickup_burden:stressed
  OPTIONS=runmode:crawl
  #OPTIONS=sortloot:full
  OPTIONS=suppress_alert:3.4.3

  ## With Menucolor Patch installed
  OPTIONS=menucolors
  MENUCOLOR="[Bb]lessed"=green
  MENUCOLOR="[Cc]ursed"=orange&bold
  MENUCOLOR="[Cc]ursed .* \(being worn\)"=red&bold
  MENUCOLOR="[Uu]ncursed"=cyan

  MENUCOLOR="[Hh]oly"=yellow
  MENUCOLOR="[Uu]nholy"=brown

  MENUCOLOR="loadstone\|wand \(of\|called\) cancellation"=red&bold
  # color only the real Amulet
  MENUCOLOR="Amulet of Yendor named"=magenta
  MENUCOLOR="gold piece"=yellow

  # forgotten spell
  MENUCOLOR="[a-zA-Z] - [a-zA-Z ]+[ ]+[0-9]+\*[ ]+[a-z]+[ ]+[0-9]+%"=magenta

  # # With Statuscolor patch installed
  # # HP
  # STATUSCOLOR=hp%100=green,hp%66=yellow,hp%50=orange
  # STATUSCOLOR=hp%33=red&bold,hp%15:red&inverse,hp%0:red&inverse&blink
  # # Pw
  # STATUSCOLOR=pw%100=green,pw%66=yellow,pw%50:orange,pw%33=red&bold
  # # Carry
  # STATUSCOLOR=burdened:yellow,stressed:orange,strained:red&bold
  # STATUSCOLOR=overtaxed:red&inverse,overloaded:red&inverse&blink
  # # Hunger
  # STATUSCOLOR=satiated:yellow,hungry:orange,weak:red&bold
  # STATUSCOLOR=fainting:red&inverse,fainted:red&inverse&blink
  # # Mental
  # STATUSCOLOR=hallu:yellow,conf:orange,stun:red&bold
  # # Health
  # STATUSCOLOR=ill:red&inverse,foodpois:red&inverse,slime:red&inverse
  # # Other
  # STATUSCOLOR=held:red&inverse,blind:red&inverse
#+END_SRC

* Aesthetics
:PROPERTIES:
:header-args: :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
:END:

I want my desktop to look good.

** No mouse cruft

Please, use all my screen real estate for information, not for "places to click on".

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tooltip-mode) (tooltip-mode -1) (setq tooltip-use-echo-area t))
  (fringe-mode '(4 . 0))
#+END_SRC

Although, I do have a mouse, and sometimes I use it to focus a window in my window manager.  That's when I like to also focus a window inside Emacs.

#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC

But, do not move my mouse pointer around.  This sometimes even caused my emacs to lose focus, because the mouse pointer just leaves the frame.

#+BEGIN_SRC emacs-lisp
  (advice-add 'set-mouse-position :override #'ignore)
#+END_SRC

** Show me info about my buffer

I want to know where am, and have immediate visual feedback about my text.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (column-number-mode)
  (show-paren-mode)
  (setq auto-window-vscroll nil)          ; This should make the next-line command faster

  (use-package nlinum
    :config (global-nlinum-mode))
#+END_SRC

** Theme to use

This is the theme I will use currently.

#+BEGIN_SRC emacs-lisp 
  (use-package leuven-theme
    :config (progn
              (load-theme 'leuven t)))
#+END_SRC

** Screens

Start with the correct resolutions.

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  ~/dotfiles/xmonad/xrandr-toggle.sh
#+END_SRC

** Transparency

I like my windows to be a bit transparent, so that I can see my desktop

*** Emacs
#+BEGIN_SRC emacs-lisp
 (set-frame-parameter (selected-frame) 'alpha '(95 . 70))
 (add-to-list 'default-frame-alist '(alpha . (95 . 70)))
#+END_SRC

*** Termite
#+BEGIN_SRC conf :tangle ~/.config/termite/config :comments noweb :tangle-mode (identity #o444) :mkdirp yes
  [colors]
  background = rgba(23, 23, 23, 0.8)
#+END_SRC

*** Composing window manager
#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  compton --backend xrender -fcCz -l -17 -t -17 -b
#+END_SRC

** Wallpapers

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  while true; do feh --bg-scale --randomize --recursive ~/Pictures; sleep 60; done &
#+END_SRC

** Emacs Mode line

#+BEGIN_SRC emacs-lisp
  ;; (use-package powerline
  ;;   :config (powerline-default-theme))
  (use-package spaceline
    :config (progn
              (require 'spaceline-config)
              (spaceline-emacs-theme)
              (spaceline-helm-mode)))
#+END_SRC

** Use UTF-8 by default

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
#+END_SRC

** Font face

I read about Hack.

#+BEGIN_SRC emacs-lisp
  (when (member "Hack" (font-family-list))
    (set-face-attribute 'default nil :font "Hack"))
#+END_SRC

Which I also like for termite, by the way.

#+BEGIN_SRC conf :tangle ~/.config/termite/config :comments noweb :tangle-mode (identity #o444) :mkdirp yes
  [options]
  font = Hack 9
#+END_SRC

Use Symbola for unicode characters

#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

** Font size

I like smaller fonts.

#+BEGIN_SRC elisp
  (set-face-attribute 'default nil :height 90)
#+END_SRC

** Window management

Use ~ace-window~ to jump to where I want.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . ace-window))
    :config (progn
              (setq aw-scope 'frame
                    aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s) ; I use Dvorak
                    )))
#+END_SRC

Kill side-windows with ~C-c q~

#+BEGIN_SRC emacs-lisp
  ;; Stolen from http://www.lunaryorn.com/posts/the-power-of-display-buffer-alist.html

  (defun joranvar:quit-bottom-side-windows ()
    "Quit bottom side windows of the current frame."
    (interactive)
    (dolist (window (window-at-side-list nil 'bottom))
      (quit-window nil window)))

  (global-set-key (kbd "C-c q") #'joranvar:quit-bottom-side-windows)
#+END_SRC

** Use pretty unicode characters

#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :init (progn (global-prettify-symbols-mode t)))
#+END_SRC

** Use icons

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :config (progn (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
                     (all-the-icons-install-fonts))))
  (use-package all-the-icons-dired
    :config (progn
              (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)))
#+END_SRC

