#+TITLE: The dotfile root

* Purpose

This file is tangled on Emacs startup, which will result in both more configuration to be loaded by Emacs and dotfiles to serve as configuration for other programs.

* Me

Who am I?

#+BEGIN_SRC emacs-lisp :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
  (setq user-full-name "Bart Post"
        user-mail-address "bart.post@gmail.com"
        epg-user-id "AE05B5A8D130BE84B88192809BD68A49AB3D8E4D")
#+END_SRC

* SSH configuration
:PROPERTIES:
:header-args: :tangle ~/.ssh/config :comments noweb :tangle-mode (identity #o400) :mkdirp yes
:END:

** Default options

I want to see a visual key to become familiar with it.

#+BEGIN_SRC conf
  Host *
       VisualHostKey yes
       ControlPath ~/.ssh/controlmasters/%r@%h:%p
       ControlMaster auto
       ControlPersist 10m
       PreferredAuthentications publickey
#+END_SRC

** Host aliases                                                       :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQf+IGGcRGdILhRChfOWwugztcoFMbYqtFhYiwSTi3IbtUsp
K4jBaRnQaPLWAfVjXQs+sV05fhJAn5FCK6ZXV4C7WZneA9UsmVqnRQuZ1pFm8mro
Errm9lxpdBL41ohMENZbfG8dLg4dlGWqceY29RPEoz2p5YwZ2Fm+Wp4tcoexjv/F
JshmAg+p2UIO+QaN9PJrejRxEChu9q2SHiz5gUa9Boa/tv0M4aV4vUqai4j+uLxL
2MOnB/xIWisop7mtgY8ebl/RH6F2+kKWwxIddkFeY79KvdOHSNo2wkInS5w0xx8N
yMXlrEj7ojLaGVXjwnJdq2nExmzmuJlsLZ0gZOvBTNLArAHCM/P/EahbJeuHwDDP
+2xqMSrUT2rr8oRAxNdzWsdacYrRGEgZM33u6Uqj+RxTEa1WwVxFkN7/JdL2nihv
KoLV06azOFCprbEu1+yK73rph1/SLqnfom7uxKSu7ziNvImie1KveufoXXybRVdM
iRxCkie/N6UzioxuIZ3Ur+pmL3MjtsaFuoT3eVCK6IRyuQi6ANEpGPsY1dytSSRb
clcBdMbjzLW9lqeOwablZaF0DIWH5YP2G3p1GprW8/F04wZxgb3KVDkX4w4hy4rO
SX7BuzrURVMtJTL1e/3qtusieobYtVspXDQX71Tn5LA2+FpCvBxYzzXOz67mzX1Q
+koCOnSM97Q+REdXR6vA8HNZjUrViaxI/Tn1T/B7H/hk1ylVtx/svGBgUkSvihCe
T7Bin23ErTy3oSF9uJCHqJDEqMajVFRbKN6JcFG2zWiGz+KzPrn8lsHUAHUs24GD
2g5/p3WupcXw4cHr40w=
=Af+M
-----END PGP MESSAGE-----

* Shell

** What was already there

This part is to replace what was already there, before I started "going literal".

*** Zsh

#+BEGIN_SRC sh :tangle ~/.zshrc :comments noweb :tangle-mode (identity #o444)
  source ~/.antigen/antigen.zsh

  antigen bundle gpg-agent
  antigen bundle git
  antigen bundle zsh-users/zsh-syntax-highlighting
  antigen use oh-my-zsh
  antigen theme candy
  antigen bundle spwhitt/nix-zsh-completions
  antigen bundle zsh-users/zsh-completions src
  antigen apply

  function weather() {curl wttr.in/$1 -f --stderr /dev/null | head -n 7;}

  export PATH=$PATH:/home/joranvar/.local/bin
#+END_SRC

*** Xprofile

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444) :shebang #!/usr/bin/env zsh
  gpg-connect-agent /bye
  GPG_TTY=$(tty)
  export GPG_TTY
  export SSH_AUTH_SOCK="/var/run/user/1000/gnupg/S.gpg-agent.ssh"

  unset SSH_AGENT_PID
#+END_SRC

** Host aliases                                                       :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQf+LLpbyzmsI/m8m54Xj6arwRueLRp/SaDamR7FKAlAK75d
nFBYhw8Ha22xkj3LuUKmBU4WIp1tGnANu4AGEXyIORpwmxlf4iArCEuvgLIshtas
8cvbKiNY5ht2oxBCyI/jyJief0g1s8ruyeZbguttoToHzGUS1a1NccysuBr9keT3
T6a8ttkxzGqxo/ML+yUP8zmamvUDDeoJoy8Pp5YRI5psMar7Q1yxbdT4d3hLMGsK
ZYbIBhFPFxvD1YbmGmzSpH2wCfug9HRzH3reY/6tmdvPu/doqlEoPZp8lL16oNVe
yYPR5VpZM46z5eX24MPA1aRdc2QcL3niTZL8ENLB6tLAeQHbgMts78lWnqZ1JnBs
DboGR/XZFx51FhlLCEW7SmKUM2MABgqp7KqW+GJRn2ovtjHd86wkWr8+qD7fM66J
WG2Np2nJkGr6KPdSOZA6QZ085f2Ii4dGQL28Emneu3OSS+w9nljvseFWcPyAOCjH
eCjFYjReu22m0zxOSXq5J+6OqJ0DYR6D+aDN2SNi1u/OA3ZHvAfFRYEVg+KOyPh0
m1TBpfdhWwhyyoeeZT8UNxF68uFILTXMOEg1GUnOaMi+Yx9zZhoB2a1PfjkXqJ4d
bP07OF4LIKlwwlDEPmUylyfnbjFrV8Lo+os2mHpvGTv8CtoqmQ4u36aZl8eR9Azg
AtI9vWqMBCNeBJXX1QEsesHib0BzhK6w007RbLlMfIRCg5qnGKzGa5z14eU+Esrx
fFp7tjvThu5sRoU=
=i7ss
-----END PGP MESSAGE-----

** Command aliases

These snippets can be quite useful, sometimes.

#+BEGIN_SRC sh :tangle ~/.zshrc :comments noweb :tangle-mode (identity #o444)
  timer () { timeout $1 zsh -c "(for i in \$(seq 1 999999); do echo -ne \\\\r$1: \$i; sleep 1; done)"; echo }
#+END_SRC

* Emacs configuration
:PROPERTIES:
:header-args: :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
:END:

** Package preparation

*** Package sources 
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

  (setq package-archives '(("gnu"          . "http://elpa.gnu.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")
                           ("melpa"        . "http://melpa.org/packages/")
                           ("org"          . "http://orgmode.org/elpa/")))

  (package-initialize)
#+END_SRC

*** ~use-package~

Then, we'll use ~use-package~ to install and configure all others.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

Ensure that a package is installed by default (why would I enter it otherwise?)

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

*** ~paradox~

Finally, we'll switch to using paradox, for its async execution and automatic updating functionalities.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :config
    (progn
      (setq paradox-execute-asynchronously t)
      (paradox-enable)
      (paradox-refresh-upgradeable-packages)))
#+END_SRC

** Custom settings

They should not be set in the generated ~init.org.el~, but sometimes I want to see what a customization does.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file) (load custom-file))
#+END_SRC

** Basic utils

~dash.el~, ~f.el~ and ~s.el~ cannot be omitted, as they provide very useful tools for emacs-lisp programming.

#+BEGIN_SRC emacs-lisp
  (use-package dash)
  (use-package s)
  (use-package f)
#+END_SRC

*** Async

Add some asyncness, for the sake of less waiting time.

#+BEGIN_SRC emacs-lisp
  (use-package async)
#+END_SRC

** Basic text editing

*** Whitespace pet peeves

Do, please do, remove whitespace from the end of lines, before saving my buffers.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode
    :diminish whitespace-mode global-whitespace-mode
    :config (progn
              (setq-default whitespace-style '(face ;spaces tabs space-mark
                                               tab-mark
                                               newline newline-mark
                                               trailing lines-tail empty
                                               indentation::space
                                               space-after-tab::space)
                            whitespace-line-column 160
                            indent-tabs-mode nil
                            require-final-newline t)
              (defadvice align-regexp (around align-regexp-with-spaces activate)
                (let ((indent-tabs-mode nil))
                  ad-do-it))
              (setq-default tab-width 2)
              (global-whitespace-mode)
              (global-whitespace-cleanup-mode)))
#+END_SRC

*** Whitespace visualisation

#+BEGIN_SRC emacs-lisp
  (use-package highlight-indent-guides
    :config (progn
              (add-hook 'prog-mode-hook #'highlight-indent-guides-mode)))
#+END_SRC

*** Search and replace

Search and replace with regexes by default, and show me what you're about to do.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :bind* (("C-c r" . anzu-query-replace-regexp)
           ("C-c C-r" . anzu-replace-at-cursor-thing)
           ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp))
    :diminish anzu-mode
    :config (progn
              (global-anzu-mode)
              (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
              (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp)))
#+END_SRC

*** Selecting stuff

Use expand-region to conveniently select more of the current surroundings.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

*** Markdown formatting

The mode itself.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode)
#+END_SRC

Previewing changes on the fly.

#+BEGIN_SRC emacs-lisp
  (use-package flymd
    :commands flymd-flyit)
#+END_SRC

** Finances

It's about time I managed my finances a bit better.  Luckily, ledger is there to help me!

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :config (add-to-list 'joranvar/babel-safe-languages "ledger"))
#+END_SRC

With ledger, I want to have the following settings, though.

#+BEGIN_SRC conf :tangle ~/.ledgerrc :comments noweb :tangle-mode (identity #o444)
  --date-format %Y-%m-%d
#+END_SRC

** Start Emacs as a server

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config (progn
              (unless (server-running-p) (server-start))))
#+END_SRC

** Menus and discovery

*** ~helm~

I've used ~helm~ for quite some time now, and I like the way it works.  Therefore, it's the default menu for everything now.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-mini))
    :diminish helm-mode
    :init (progn
            (require 'helm-config)
            (helm-mode 1)
            (helm-autoresize-mode t)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :bind ("C-x C-b" . ibuffer))
#+END_SRC

** Projects

Each project is either a version controlled (~magit~!) directory, or some directory I want to be able to browse at once (local repos of files, e.g. videos or pictures).

*** Version control

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-git-repo-p
               magit-status-internal)
    :bind (("C-c g" . magit-status))
    :config
    (setq magit-commit-arguments (if (eq system-type 'gnu/linux)
                                     (list (s-concat "--gpg-sign=" epg-user-id))
                                   '(""))
          magit-diff-arguments '("--ignore-space-change"
                                 "--ignore-all-space"
                                 "--no-ext-diff"
                                 "-M"
                                 "-C")
          magit-log-arguments '("--graph"
                                "--color"
                                "--decorate"
                                "--show-signature"
                                "-n256")
          magit-merge-arguments '("--no-ff")
          magit-rebase-arguments '("--autostash")
          magit-diff-refine-hunk 'all
          ediff-window-setup-function #'ediff-setup-windows-plain)
    (use-package git-timemachine)
    (when (eq system-type 'windows-nt)
      (setq magit-git-executable "c:/Program Files/Git/bin/git.exe")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :config (progn
              (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
              (global-diff-hl-mode)))
#+END_SRC

*** Navigation

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind (("M-P" . helm-projectile))
    :diminish projectile-mode
    :config (progn
              (projectile-global-mode)
              (setq projectile-indexing-method 'alien
                    projectile-completion-system 'helm
                    ;; projectile-enable-caching t ;; This messes up tramp-sudo, see https://github.com/bbatsov/projectile/issues/835
                    projectile-enable-idle-timer t)
              (use-package helm-ag)
              (use-package helm-projectile
                :config (progn
                          (helm-projectile-on)))
              (use-package neotree
                :config (progn
                          (setq neo-smart-open t)
                          (setq neo-theme 'icons)
                          (setq projectile-switch-project-action (lambda ()
                                                                   (if (magit-git-repo-p (projectile-project-root))
                                                                       (magit-status-internal (projectile-project-root))
                                                                     (dired (projectile-project-root)))
                                                                   ;; (neotree-projectile-action)
                                                                   ))))
              (setq magit-repository-directories (mapcar (lambda (dir)
                                                           (substring dir 0 -1))
                                                         (-filter (lambda (project)
                                                                    (file-directory-p (concat project "/.git/")))
                                                                  (projectile-relevant-known-projects)))
                    magit-repository-directories-depth 1)))
#+END_SRC

** Completion

*** ~company~

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :config (progn
              (global-company-mode)
              (setq company-idle-delay 0.1)))
#+END_SRC

** Programming

*** General stuff

I use flycheck for almost any buffer that can be checked, so enable it everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config (progn
              (global-flycheck-mode)
              (add-to-list 'display-buffer-alist
                           `(,(rx bos "*Flycheck errors*" eos)
                             (display-buffer-reuse-window
                              display-buffer-in-side-window)
                             (reusable-frames . visible)
                             (side            . bottom)
                             (window-height   . 10)))))
#+END_SRC

I like my parentheses balanced, thank you!

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config (progn
              (require 'smartparens-config)
              (show-smartparens-global-mode)
              (smartparens-global-strict-mode)
              (sp-use-paredit-bindings)))
#+END_SRC

Also, please indent my code smartly (except for in F#, it does not play nice there)!

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config (progn
              (global-aggressive-indent-mode)
              (add-to-list 'aggressive-indent-excluded-modes 'org-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package recompile-on-save
    :bind (("C-c m" . recompile-on-save))
    :config (progn
              (recompile-on-save-advice compile)
              (setq compilation-scroll-output 'first-error)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package makefile-executor
    :config (progn
              (add-hook 'makefile-hook #'makefile-executor-mode)))
#+END_SRC

*** Remote compilation with NCrunch and ssh/rsync

#+BEGIN_SRC emacs-lisp
  (defun joranvar/ncrunch-match-file ()
    (s-replace "\\" "/" (match-string-no-properties 1)))

  (add-to-list 'compilation-error-regexp-alist
               (list (rx "ERROR (Build): "
                         (0+ nonl) "\\NCrunch\\" (1+ digit) "\\" (1+ digit) "\\"
                         (group-n 1 (1+ nonl)) space "(" (group-n 2 (1+ digit)) "):") 'joranvar/ncrunch-match-file 2 nil 2))
#+END_SRC

*** F#

In F#, I'd like to set the following settings:

#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode
    :config (progn
              (setq fsharp-indent-offset 2)
              (add-to-list 'aggressive-indent-excluded-modes 'fsharp-mode)))
#+END_SRC

*** C#

In C#, the following:

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :config (progn
              (setq csharp-indent-offset 4)))
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :config (progn
              (require 'haskell-indentation)
              (use-package hlint-refactor
                :config (add-hook 'haskell-mode-hook 'hlint-refactor-mode))
              (use-package company-ghc
                :config (add-to-list 'company-backends 'company-ghc))
              (setq company-ghc-show-info t)
              (add-to-list 'aggressive-indent-excluded-modes 'haskell-mode)))
#+END_SRC

In Haskell, use `dante`.

#+BEGIN_SRC emacs-lisp
  (use-package dante
    :commands 'dante-mode
    :init (progn
            (add-hook 'haskell-mode-hook 'dante-mode)))
#+END_SRC

*** Yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'"
    :config (add-to-list 'aggressive-indent-excluded-modes 'yaml-mode))
#+END_SRC

*** PowerShell

#+BEGIN_SRC emacs-lisp
  (use-package powershell
    :mode "\\.ps\\'"
    :config (add-to-list 'aggressive-indent-excluded-modes 'powershell-mode))
#+END_SRC

*** Nix

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :config (add-to-list 'aggressive-indent-excluded-modes 'nix-mode))
  (use-package company-nixos-options
    :config (progn (add-to-list 'company-backends 'company-nixos-options)))
#+END_SRC

*** ELisp

#+BEGIN_SRC emacs-lisp
  (use-package ipretty
    :config (progn (ipretty-mode)))
#+END_SRC

*** XML

Show where I am in xml

#+BEGIN_SRC emacs-lisp
  (defun nxml-where ()
    "Display the hierarchy of XML elements the point is on as a
  path. from http://www.emacswiki.org/emacs/NxmlMode"
    (interactive)
    (let ((path nil))
      (save-excursion
        (save-restriction
          (widen)
          (while
              (and (< (point-min) (point)) ;; Doesn't error if point is at
                   ;; beginning of buffer
                   (condition-case nil
                       (progn
                         (nxml-backward-up-element) ; always returns nil
                         t)
                     (error nil)))
            (setq path (cons (xmltok-start-tag-local-name) path)))
          (if (called-interactively-p t)
              (message "/%s" (mapconcat 'identity path "/"))
            (format "/%s" (mapconcat 'identity path "/")))))))
#+END_SRC

** Mail configuration

I used to check mail with Gnus, directly from the imap-server (in the Exchange case, from davmail), but the Gnus/davmail combination is quite slow, and when checking mail, freezes Emacs a bit.
After reading http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/, I decided to setup a different configuration, and use offlineimap.
Reading https://nakkaya.com/2010/04/10/using-offlineimap-with-gnus/ after that, I decided to skip the mu4e, and use the nnmaildir backend in Gnus.
This backend, however, needs a script to be run for syncing the flags with a "regular" Maildir backend.

*** Flag syncing script
:PROPERTIES:
:header-args: :tangle ~/sync_nnmaildir :comments noweb :tangle-mode (identity #o555) :shebang "#!/usr/bin/env perl"
:END:

This script was downloaded (and adjusted a tiny bit) from http://groups.google.com/group/linux.debian.user/msg/7594165a2b6d1c49.

#+BEGIN_SRC perl
  # Maildir flags are:
  #         D (draft)
  #         F (flagged)
  #         R (replied)
  #         S (seen)
  #         T (trashed)
  # and must occur in ASCII order.
  #
  # flagmatchre = re.compile(':.*2,([A-Z]+)')
  #
  # filename:2,F   => .nnmaildir/marks/tick/filename
  # filename:2,R   => .nnmaildir/marks/reply/filename
  # filename:2,S   => .nnmaildir/marks/read/filename

  use strict;
  use File::Basename;
  use Getopt::Long;
  $Getopt::Long::ignorecase = 0;

  my $from_gnus = 0;
  my $from_maildir = 0;
  my $dir = "~/Maildir";
  GetOptions('-g' => \$from_gnus,
             '-m' => \$from_maildir,
             '-d=s' => \$dir);

  if (! ($from_gnus ^ $from_maildir)) {
      die "Usage: sync_nnmaildir -g [-f]\n   or: sync_nnmaildir -m [-v -f]\n";
  }

  for (glob "$dir/*") {
      my $mb = $_;
      mkdir "$mb/.nnmaildir";
      mkdir "$mb/.nnmaildir/marks";

      for (glob "$mb/cur/*") {
          my $file = $_;

          /(.*)\/cur\/(.*?):.*2,(.*)$/;
          my $path = $1;
          my $message = $2;
          my $flags = $3;

          if ($from_maildir) {
              # Sync ticked flags
              if ($flags =~ /F/) {
                  mkdir "$path/.nnmaildir/marks/tick";
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir ticks\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir ticks\n";
              }

              # Sync replied flags
              if ($flags =~ /R/) {
                  mkdir "$path/.nnmaildir/marks/reply";
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir replies\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir replies\n";
              }

              # Sync read flags
              if ($flags =~ /S/) {
                  mkdir "$path/.nnmaildir/marks/read";
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir seen\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir seen\n";
              }
          } elsif ($from_gnus) {
              my $new_flags = '';

              if (-e "$path/.nnmaildir/marks/tick/$message") {
                  $new_flags = $new_flags . 'F';
              }
              if (-e "$path/.nnmaildir/marks/reply/$message") {
                  $new_flags = $new_flags . 'R';
              }
              if (-e "$path/.nnmaildir/marks/read/$message") {
                  $new_flags = $new_flags . 'S';
              }

              if ($new_flags ne $flags) {
                  rename "$file", "$path/cur/$message:2,$new_flags"
                      and print "Marked mail in $mb as $new_flags\n";
              }
          }
      }
  }

#+END_SRC

*** Offline imap
:PROPERTIES:
:header-args: :tangle ~/.offlineimaprc :comments noweb :tangle-mode (identity #o444)
:END:

#+BEGIN_SRC conf
  [general]
  accounts = Gmail, Exchange
  maxsyncaccounts = 2
  pythonfile = ~/.offlineimap.py

  [Account Gmail]
  localrepository = LocalGmail
  remoterepository = RemoteGmail
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g

  [Repository LocalGmail]
  type = Maildir
  localfolders = ~/Maildir/Gmail

  [Repository RemoteGmail]
  type = Gmail
  maxconnections = 2
  remoteuser = bart.post@gmail.com
  remotepasseval = get_password_emacs("gmail", "imaps")
  folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail', '[Gmail]/Important']
  sslcacertfile = /etc/ssl/certs/ca-certificates.crt

  # These are effectively the same as the above
  [Account Exchange]
  localrepository = LocalExchange
  remoterepository = RemoteExchange
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g

  [Repository LocalExchange]
  type = Maildir
  localfolders = ~/Maildir/Exchange

  # This uses davmail
  [Repository RemoteExchange]
  type = IMAP
  maxconnections = 2
  remoteuser = bart.post@cgm.com
  remotehost = localhost
  remotepasseval = get_password_emacs("localhost", "1143")
  remoteport = 1143
  ssl = no
  sync_deletes = no

  sslcacertfile = /etc/ssl/certs/ca-certificates.crt
#+END_SRC

*** Password management with .authinfo.gpg

This python script will be used to get the credentials.

#+BEGIN_SRC python :tangle ~/.offlineimap.py :comments noweb :tangle-mode (identity #o444)
  import subprocess
  def get_output(cmd):
    # Bunch of boilerplate to catch the output of a command:
    pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (output, errout) = pipe.communicate()
    assert pipe.returncode == 0 and not errout
    return output
  def get_password_emacs(host, port):
    cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\")'" % (host,port)
    return get_output(cmd).strip().lstrip('"').rstrip('"')
#+END_SRC

And this is the code that will be used to decrypt the authinfo.

#+BEGIN_SRC emacs-lisp
  (use-package offlineimap
    :config (progn
              (setq auth-sources (list "~/.authinfo.gpg"))
              (defun offlineimap-get-password (host port)
                (let ((netrc (nth 0 (auth-source-search
                                     :host host
                                     :port port))))
                  (when netrc (let ((secret (plist-get netrc :secret)))
                                (if (functionp secret)
                                    (funcall secret)
                                  secret)))))
              (defun offlineimap-get-username (host port)
                (let ((netrc (nth 0 (auth-source-search
                                     :host host
                                     :port port))))
                  (when netrc (let ((user (plist-get netrc :user)))
                                (if (functionp user)
                                    (funcall user)
                                  user)))))))
#+END_SRC

*** Gnus

Gnus will be used to read the mail that was pulled over here.

#+BEGIN_SRC emacs-lisp
  (use-package gnus
    :config (progn
              (setq gnus-select-method '(nnmaildir "GMail"
                                                   (directory "~/Maildir/Gmail")
                                                   (directory-files nnheader-directory-files-safe)
                                                   (get-new-mail nil))
                    gnus-secondary-select-methods '((nnmaildir "Exchange"
                                                               (directory "~/Maildir/Exchange")
                                                               (directory-files nnheader-directory-files-safe)
                                                               (get-new-mail nil))
                                                    (nntp "news.usenetserver.com")
                                                    (nntp "news.gwene.org"))
                    mm-discouraged-alternatives '("text/html" "text/richtext") ;; Prefer text/plain
                    gnus-decay-scores t
                    gnus-fetch-old-headers nil
                    gnus-build-sparse-threads t
                    gnus-visible-headers "^From:\\|^Newsgroups:\\|^Subject:\\|^Date:\\|^Followup-To:\\|^Reply-To:\\|^Organization:\\|^Summary:\\|^Keywords:\\|^To:\\|^[BGF]?Cc:\\|^Posted-To:\\|^Mail-Copies-To:\\|^Mail-Followup-To:\\|^Apparently-To:\\|^Gnus-Warning:\\|^Resent-From:\\|^User-Agent:\\|^X-Newsreader:\\|X-MS-Has-Attach:\\|X-Mailer:"
                    gnus-use-adaptive-scoring t)
              (when window-system
                (setq gnus-sum-thread-tree-indent "  ")
                (setq gnus-sum-thread-tree-root "● ")
                (setq gnus-sum-thread-tree-false-root "◯ ")
                (setq gnus-sum-thread-tree-single-indent "◎ ")
                (setq gnus-sum-thread-tree-vertical        "│")
                (setq gnus-sum-thread-tree-leaf-with-other "├─► ")
                (setq gnus-sum-thread-tree-single-leaf     "╰─► "))
              (setq-default gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
                            gnus-user-date-format-alist '((t . "%Y-%m-%dT%T%z"))
                            gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
                            gnus-thread-sort-functions '(gnus-thread-sort-by-number (not gnus-thread-sort-by-total-score))
                            gnus-subthread-sort-functions '(gnus-sort-thread-by-number))
              (add-hook 'gnus-group-mode-hook 'gnus-topic-mode) ;; Show me topics
              (add-hook 'gnus-startup-hook (lambda () (gnus-demon-add-handler (lambda () (gnus-group-get-new-news 2)) 1 t)))
              (use-package gnus-desktop-notify
                :config (progn
                          (gnus-desktop-notify-mode)))
              (gnus-add-configuration
               '(article
                 (horizontal 1.0
                             (vertical 50
                                       (group 1.0))
                             (vertical 1.0
                                       (summary 0.25 point)
                                       (article 1.0)))))
              (gnus-add-configuration
               '(summary
                 (horizontal 1.0
                             (vertical 50
                                       (group 1.0))
                             (vertical 1.0
                                       (summary 1.0 point)))))))
#+END_SRC

*** BUG FIX

[[gnus:nntp+news.usenetserver.com:gnu.emacs.gnus#mailman.400.1505223107.14750.info-gnus-english@gnu.org][Email from Reiner Steib: Security: Gnus & GNU Emacs 25.]]

#+BEGIN_SRC emacs-lisp
  (eval-after-load "enriched"
    '(defun enriched-decode-display-prop (start end &optional param)
       (list start end)))
#+END_SRC

*** notmuch

Notmuch will also be used to read the mail that was pulled over here.  Let's see how it compares to Gnus.

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :disabled
    :bind (("C-c m" . notmuch-hello)))
#+END_SRC

*** GPG for mails

#+BEGIN_SRC emacs-lisp
  (use-package epg
    :config (progn
              (setq mml2015-use 'epg

                    mml2015-verbose t
                    mml2015-encrypt-to-self t
                    mml2015-always-trust nil
                    mml2015-cache-passphrase t
                    mml2015-passphrase-cache-expiry '36000
                    mml2015-sign-with-sender t

                    gnus-message-replyencrypt t
                    gnus-message-replysign t
                    gnus-message-replysignencrypted t
                    gnus-treat-x-pgp-sig t

                    ;; mm-sign-option 'guided
                    ;; mm-encrypt-option 'guided
                    mm-verify-option 'always
                    mm-decrypt-option 'always
                    gnus-buttonized-mime-types '("multipart/alternative" "multipart/encrypted" "multipart/signed"))
              (add-hook 'gnus-message-setup-hook (lambda () (mml-secure-message-sign)))))
#+END_SRC

*** Sending mail

When sending a mail, it should reflect who I want to send it as (from my work mail, or personal).

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail
    :config (progn
              (require 'message)
              (setq gnus-posting-styles
                    '((".*"
                       (signature "")
                       (address "bart.post@gmail.com")
                       ("X-Message-SMTP-Method" "smtp smtp.gmail.com 587 bart.post@gmail.com"))
                      ("Exchange"
                       (signature "Bart Post\nApplication Programmer Team Satellite\nCompugroup Medical B.V.")
                       (address "bart.post@cgm.com")
                       ("X-Message-SMTP-Method" "smtp localhost 1025 bart.post@cgm.com"))))
              (setq smtpmail-stream-type nil
                    mail-user-agent 'message-user-agent
                    smtpmail-smtp-service 587
                    message-send-mail-function 'smtpmail-send-it
                    smtpmail-default-smtp-server "smtp.gmail.com"
                    send-mail-function 'smtpmail-send-it
                    message-cite-style '((message-citation-line-format "On %Y-%m-%dT%T%z, %f wrote:")
                                         (message-cite-function 'message-cite-original-without-signature)
                                         (message-citation-line-function 'message-insert-formatted-citation-line)
                                         (message-cite-reply-position 'traditional)
                                         (message-yank-prefix "> ")
                                         (message-yank-cited-prefix ">")
                                         (message-yank-empty-prefix ">")))))
#+END_SRC

Also, I want to be able to compose mail in org-mode and send it as html.

#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :config (progn
              (add-hook 'message-mode-hook
                        (lambda ()
                          (orgstruct-mode)
                          (local-set-key "\C-co" (lambda ()
                                                    (interactive)
                                                    (save-excursion
                                                      (message-goto-body)
                                                      (when (looking-at "<#secure.*>") (forward-line 1))
                                                      (set-mark-command nil)
                                                      (insert "#+OPTIONS: toc:nil ^:nil\n")
                                                      (goto-char (point-max))
                                                      (org-mime-htmlize nil))))))
              (add-hook 'org-mode-hook
                        (lambda () (local-set-key "\C-co" 'org-mime-org-buffer-htmlize)))))

#+END_SRC

** Browsing

Use conkeror by default.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-generic-program (executable-find "conkeror")
        browse-url-browser-function 'browse-url-generic)
#+END_SRC

Use conkeror-minor-mode.

#+BEGIN_SRC emacs-lisp
  (use-package conkeror-minor-mode
    :config (progn
              (add-to-list 'auto-mode-alist' ("conkerorrc" . js-mode))
              (add-hook 'js-mode-hook (lambda ()
                                        (when (string-match "conkerorrc" (buffer-file-name))
                                          (conkeror-minor-mode))))))
#+END_SRC

Use ~moz-repl~ to communicate with conkeror.

#+BEGIN_SRC emacs-lisp
  (use-package moz
    :commands moz-minor-mode
    :init (progn
              (add-hook 'javascript-mode-hook (lambda () (moz-minor-mode 1)))))
#+END_SRC

** Literate programming

Oh boy, org-babel is so nice!

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :init (progn
            (defvar joranvar/babel-safe-languages nil))
    :config (progn
              (use-package ob-http)
              (org-babel-do-load-languages 'org-babel-load-languages '((sql . t)
                                                                       (shell . t)
                                                                       (ledger . t)
                                                                       (http . t)))
              (defun joranvar/babel-safe-languagep (lang body)
                (not (--any (string= lang it) joranvar/babel-safe-languages)))
              (setq org-confirm-babel-evaluate #'joranvar/babel-safe-languagep)))
#+END_SRC

When exporting, I want to see pretty source code!

#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

Also: exported listings should be pretty.

#+BEGIN_SRC emacs-lisp
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-minted-options '(("breaklines"))
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

** Agenda management

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package org
    :bind (("C-c a" . org-agenda)
           ("C-c c" . org-capture))
    :config (progn
              (setq org-use-sub-superscripts '{}
                    org-pretty-entities t
                    org-fontify-emphasized-text t
                    org-adapt-indentation nil
                    org-hide-leading-stars t
                    org-ellipsis "↷"
                    org-catch-invisible-edits 'error
                    org-use-speed-commands t
                    org-todo-keywords '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)"))
                    org-agenda-span 1
                    org-agenda-skip-scheduled-if-done t
                    org-agenda-skip-timestamp-if-done t
                    org-clock-report-include-clocking-task t
                    org-refile-use-outline-path t
                    org-outline-path-complete-in-steps nil
                    org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t% s")
                                               (timeline . "  % s")
                                               (todo . " %i %-12:c")
                                               (tags . " %i %-12:c")
                                               (search . " %i %-12:c")))
              <<gtd-setup>>
              ))
#+END_SRC

*** My GTD setup

I just based this on https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html, which is really like setups I've used before.

#+NAME: gtd-setup
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-agenda-files '("~/org/inbox.org"
                           "~/org/gtd.org"
                           "~/org/tickler.org")
        org-refile-targets '(("~/org/gtd.org" :maxlevel . 3)
                             ("~/org/someday.org" :level . 1)
                             ("~/org/tickler.org" :maxlevel . 2))
        org-capture-templates '(("t" "Todo [inbox]" entry
                                 (file+headline "~/org/inbox.org" "INBOX")
                                 "* TODO %i%?\n%U\n%a\n"
                                 :clock-in t :clock-resume t)
                                ("i" "Interrupt" entry
                                 (file+headline "~/org/inbox.org" "Interrupts")
                                 "* %i%? :@interrupt:\n%U\n"
                                 :clock-in t :clock-resume t)
                                ("T" "Tickler" entry
                                 (file+headline "~/org/tickler.org" "Tickler")
                                 "* %i%?\n%^t%a\n"))
        org-agenda-custom-commands '((" " "Default" ((agenda "")
                                                     (todo "" ((org-agenda-overriding-header "INBOX")
                                                               (org-agenda-files '("~/org/inbox.org"))))
                                                     (todo "" ((org-agenda-overriding-header "Next Action")
                                                               (org-agenda-skip-function #'joranvar:org-agenda-skip-all-siblings-but-first)
                                                               (org-agenda-files (remove "~/org/inbox.org" org-agenda-files))
                                                               (org-agenda-prefix-format '((todo . " %-50b %-12:c")))))))
                                     ("o" "At the office" tags-todo "@office"
                                      ((org-agenda-overriding-header "Office")
                                       (org-agenda-skip-function #'joranvar:org-agenda-skip-all-siblings-but-first)))))

  (defun joranvar:org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
#+END_SRC

*** Jira worklog integration

#+BEGIN_SRC emacs-lisp
  (load "/home/joranvar/dotfiles/emacs.d/lisp/org-log-to-jira/org-log-to-jira.el")
#+END_SRC

** Communication

*** IRC

Using RCIRC for IRC makes sense.  I also use it to connect to my team's Slack.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package rcirc
    :config (progn
              (rcirc-track-minor-mode)
<<irc-servers>>
              (add-to-list 'rcirc-markup-text-functions #'rcirc-smileys)))

    (defvar rcirc-smileys '((":)" . "☺")
                            (":(" . "☹")
                            ("<3" . "♥")))

    (defvar rcirc-smiley-regexp
      (regexp-opt (mapcar 'car rcirc-smileys))
      "Regular expression matching the keys in rcirc-smileys.")

    (defun rcirc-smileys (&rest ignore)
      "Use unicode smileys in the buffer"
      (goto-char (point-min))
      (while (re-search-forward rcirc-smiley-regexp nil t)
        (replace-match (cdr (assoc (match-string 0) rcirc-smileys)))))
#+END_SRC

**** IRC servers                                                      :crypt:
-----BEGIN PGP MESSAGE-----

hQELA6k/ZHkmEjnXAQf3YnBQBI3U849OWPrHJDYaRT3fqBCTTHSP6dso+6bwoCrq
uhmPfVuplqfncUzrJRHaSXPgR1UdLD5Rltfp4gqQQGL3rjNrPpDjEtfeFyQ1s582
HT+9j1ip+BrOQ53eN2XmpJ1qi19PMvgJBI6rarsLPqT56BB1+OySufab+Ceou55j
Lp2zlQBjCCAD/eT+pIb14vuJbIb0vuFima/R404ZILWvC7Fw4D7n9CxAWN1M24WK
mJfoavCWsWAbwqr7WYOECAqbBMMYLn2MZ0PshdQX0EsSMS6k11PeA+S1YCrthIx0
gIuw5TUTl5We95UVQd+xMOSJdua2Cj0jmu488sde0sA7AU8cNBtxOiC2h43Aaq3p
OS4MIE4KZNzVz0dXQXq6irtu7qBl78OOq2KrhmbUcuJxmtXfv4aK04IbVWbSReS2
XT3OmvuI6mx4n3kqKZVpHWCAbPHo2bPfYHw3FwvdixBGZ7ztFsv7fJqMjDL3+LDH
OpwqhzQBLSrggQbSAdZMPO8txrNqeSBKWkkUgeL+UA2tH9GO6DzSIyywmMtKd47X
2IhmCO4ahWEcvtrUwzfqHMcMfzV1FL1VGRDaKk0U37JwrduJnQsEEJjr8swqWTWL
FKnH70MC3UsIcxAGxFPVieoyiIOnH3rccXVj12t+GPeNV4Yv8l6nK0P8X5A=
=tRx+
-----END PGP MESSAGE-----

*** Slack

I used to use the IRC gateway for Slack, but now I'm using the `slack` package.

#+BEGIN_SRC emacs-lisp :noweb yes
  (use-package slack
    :commands (slack-start)
    :init (progn
            (setq slack-buffer-emojify t)
            (setq slack-prefer-current-team t))
    :config (progn
<<slack-teams>>
))
#+END_SRC

*** Slack teams                                                       :crypt:
-----BEGIN PGP MESSAGE-----

hQEMA6k/ZHkmEjnXAQf/cf6UyeH4GJ3J/9DWZbw9MC/TK1ciehxQpde8nJQzzNFl
SxW207G7txHzu1tdlr8c5hJiXOGcoGBFRDJn/tCsTlO+4yD6AraNxmbzQ7cRVJbn
Q9jZOa8Sqcn4D1Fe1QTPoO6Ga7SS1+Bfo+UtPU6qljC82Wej1z1mHf+Oy59jJ28o
2Sgurj4Uao8kJKLp4z4FxBcHCcaOViUHWc0taCfE21eCZLojTq1joVZFdCCaf/5/
jAtQ3sYfEUX5BygyXMdZaaZtudQX2Gu8zYI7/cpA5R0mp3DKIj0lidlg17wPBzo4
r1/27CknyMTGlWQDUwVG/ofwWc32vdbH795fn/P3YtLAzgERhpyYkwZug6OvZOcq
Qad4cPYRnTd8H+eNPTW2b14iw14CW1A5z5kAFn2Z8NGv6SlwBIbAceleNwn+YIzd
fR6/+FqdxxRB+ZJlDg5ORaGcVPpAMd5FwrXXi+y4lW1IlSp572rFdL4bLqhhEkqL
fQE6QpdwnIAknDQQFezitqesEMwO44/djo6gmpjV0+AEawUsqTU8PUa07v5XjiKc
HtcMt7Dv9d1nR68UnToQzdNv8EzlOCNZXE65RcCa0XdCEsEzfjh0v4yvXkOG9TLJ
TNTv1SBE8HYM6F1J+GaIwAVLvPN8gCaSqmF4rWoHNgyZToMiBIq+Z96m1FSDOnMC
BzieeonRKtrBUnbzheiLijICtdqg3ZLBWbnbKLRZ1l7aEvVen1N29Vui9xqL9Hcg
vO8MbRJ2/WnE4Ouk4E4dEuic1M0EVcrPiaE0DOoddirGsVlrV5e+sgwmhgAqjiJT
K0q0KimTwxIiVX257doxbNBwnaOd63GFk/dWZIUyX0Gf7/1yj4PAkTf5yPnjOGiL
=ySpm
-----END PGP MESSAGE-----

** Secrets

Some stuff I want to be kept hidden from others.  Luckily, we have gpg (and org-crypt)

#+BEGIN_SRC emacs-lisp
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  (setq org-crypt-key epg-user-id)
  (advice-add 'org-babel-tangle :around
              (lambda (oldfun &rest args)
                (org-decrypt-entries)
                (remove-hook 'before-save-hook 'org-encrypt-entries t)
                (apply oldfun args)
                (add-hook 'before-save-hook 'org-encrypt-entries nil t)
                (org-encrypt-entries)))
#+END_SRC

* Games

** Nethack

#+BEGIN_SRC conf :tangle ~/.nethackrc :comments noweb :tangle-mode (identity #o400)
  # Compound options
  OPTIONS=role:wizard
  OPTIONS=race:elf
  OPTIONS=align:chaotic
  OPTIONS=gender:male
  #OPTIONS=name:joranvar
  OPTIONS=catname:Fluffy
  OPTIONS=dogname:Bally
  OPTIONS=horsename:Tricksy
  #OPTIONS=pettype:cat
  OPTIONS=autopickup
  # cash, amulets, scrolls, spellbooks, potions, rings, wands
  #* # NOT gems/rocks
  OPTIONS=pickup_types:$"?+!=/
  # Well, this is nice: "

  OPTIONS=autodig
  OPTIONS=autoquiver
  OPTIONS=checkpoint
  OPTIONS=nocmdassist
  OPTIONS=color
  OPTIONS=confirm
  OPTIONS=DECgraphics
  OPTIONS=noeight_bit_tty
  OPTIONS=extmenu
  OPTIONS=fixinv
  OPTIONS=help
  #OPTIONS=hp_monitor
  OPTIONS=hilite_pet
  OPTIONS=noignintr
  OPTIONS=lit_corridor
  OPTIONS=lootabc
  OPTIONS=mail
  OPTIONS=null
  #OPTIONS=noparanoid_hit
  #OPTIONS=noparanoid_quit
  #OPTIONS=paranoid_remove
  OPTIONS=prayconfirm
  OPTIONS=pushweapon
  OPTIONS=norest_on_space
  OPTIONS=safe_pet
  #OPTIONS=showborn
  #OPTIONS=noshowbuc
  OPTIONS=showexp
  OPTIONS=showrace
  OPTIONS=showscore
  OPTIONS=silent
  OPTIONS=sortpack
  OPTIONS=sparkle
  OPTIONS=nostandout
  OPTIONS=time
  OPTIONS=travel
  #OPTIONS=use_darkgray
  OPTIONS=nouse_inverse
  OPTIONS=verbose
  #OPTIONS=win_edge
  # Compound options
  OPTIONS=msghistory:20
  OPTIONS=boulder:0
  OPTIONS=disclose:+i +a +v +g +c
  OPTIONS=fruit:snozberry
  OPTIONS=menustyle:full
  OPTIONS=menu_headings:inverse
  OPTIONS=msg_window:reversed
  OPTIONS=number_pad:1
  OPTIONS=pickup_burden:stressed
  OPTIONS=runmode:crawl
  #OPTIONS=sortloot:full
  OPTIONS=suppress_alert:3.4.3

  ## With Menucolor Patch installed
  OPTIONS=menucolors
  MENUCOLOR="[Bb]lessed"=green
  MENUCOLOR="[Cc]ursed"=orange&bold
  MENUCOLOR="[Cc]ursed .* \(being worn\)"=red&bold
  MENUCOLOR="[Uu]ncursed"=cyan

  MENUCOLOR="[Hh]oly"=yellow
  MENUCOLOR="[Uu]nholy"=brown

  MENUCOLOR="loadstone\|wand \(of\|called\) cancellation"=red&bold
  # color only the real Amulet
  MENUCOLOR="Amulet of Yendor named"=magenta
  MENUCOLOR="gold piece"=yellow

  # forgotten spell
  MENUCOLOR="[a-zA-Z] - [a-zA-Z ]+[ ]+[0-9]+\*[ ]+[a-z]+[ ]+[0-9]+%"=magenta

  # # With Statuscolor patch installed
  # # HP
  # STATUSCOLOR=hp%100=green,hp%66=yellow,hp%50=orange
  # STATUSCOLOR=hp%33=red&bold,hp%15:red&inverse,hp%0:red&inverse&blink
  # # Pw
  # STATUSCOLOR=pw%100=green,pw%66=yellow,pw%50:orange,pw%33=red&bold
  # # Carry
  # STATUSCOLOR=burdened:yellow,stressed:orange,strained:red&bold
  # STATUSCOLOR=overtaxed:red&inverse,overloaded:red&inverse&blink
  # # Hunger
  # STATUSCOLOR=satiated:yellow,hungry:orange,weak:red&bold
  # STATUSCOLOR=fainting:red&inverse,fainted:red&inverse&blink
  # # Mental
  # STATUSCOLOR=hallu:yellow,conf:orange,stun:red&bold
  # # Health
  # STATUSCOLOR=ill:red&inverse,foodpois:red&inverse,slime:red&inverse
  # # Other
  # STATUSCOLOR=held:red&inverse,blind:red&inverse
#+END_SRC

* Aesthetics
:PROPERTIES:
:header-args: :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
:END:

I want my desktop to look good.

** No mouse cruft

Please, use all my screen real estate for information, not for "places to click on".

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tooltip-mode) (tooltip-mode -1) (setq tooltip-use-echo-area t))
  (fringe-mode '(4 . 0))
#+END_SRC

Although, I do have a mouse, and sometimes I use it to focus a window in my window manager.  That's when I like to also focus a window inside Emacs.

#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC

But, do not move my mouse pointer around.  This sometimes even caused my emacs to lose focus, because the mouse pointer just leaves the frame.

#+BEGIN_SRC emacs-lisp
  (advice-add 'set-mouse-position :override #'ignore)
#+END_SRC

** Show me info about my buffer

I want to know where am, and have immediate visual feedback about my text.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (column-number-mode)
  (show-paren-mode)
  (setq auto-window-vscroll nil)          ; This should make the next-line command faster

  (use-package nlinum
    :config (progn
              (add-hook 'prog-mode-hook #'nlinum-mode)))
#+END_SRC

** Theme to use

This is the theme I will use currently.

#+BEGIN_SRC emacs-lisp 
  (use-package tao-theme
    :config (progn
              (load-theme 'tao-yang t)))
#+END_SRC

And these are the colors.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-identifiers
    :config (progn
              ;;; Source: https://www.reddit.com/r/emacs/comments/6xpzx6/subword_syntax_highlighting_with/ by /u/gottabeme
              (defun rainbow-identifiers--matcher (end)
                "The matcher function to be used by font lock mode."
                (catch 'rainbow-identifiers--matcher
                  (while (re-search-forward (rx word-start (*? any) word-end) end t)
                    (let ((beginning (match-beginning 0))
                          (end (match-end 0)))
                      (when (run-hook-with-args-until-failure 'rainbow-identifiers-filter-functions beginning end)
                        (let* ((identifier (buffer-substring-no-properties beginning end))
                               (hash (rainbow-identifiers--hash-function identifier)))
                          (setq rainbow-identifiers--face (funcall rainbow-identifiers-choose-face-function hash))
                          (throw 'rainbow-identifiers--matcher t)))))
                  nil))
              (add-hook 'prog-mode-hook 'rainbow-identifiers-mode)))
#+END_SRC

** Screens

Start with the correct resolutions.

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  ~/dotfiles/xmonad/xrandr-toggle.sh
#+END_SRC

** Transparency

I like my windows to be a bit transparent, so that I can see my desktop

*** Emacs
#+BEGIN_SRC emacs-lisp
 (set-frame-parameter (selected-frame) 'alpha '(95 . 70))
 (add-to-list 'default-frame-alist '(alpha . (95 . 70)))
#+END_SRC

*** Termite
#+BEGIN_SRC conf :tangle ~/.config/termite/config :comments noweb :tangle-mode (identity #o444) :mkdirp yes
  [colors]
  background = rgba(23, 23, 23, 0.8)
#+END_SRC

*** Composing window manager
#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  compton --backend xrender -fcCz -l -17 -t -17 --inactive-dim 0.5 --xrender-sync --unredir-if-possible --detect-transient &
#+END_SRC

** Wallpapers

A simple wallpaper clock.

#+BEGIN_SRC sh :tangle ~/bin/wallpaperclock :comments noweb :tangle-mode (identity #o755) :mkdirp yes :shebang "#!/usr/bin/env bash"
  source ~/.wallpaperclock
  hours=$(ls $WCZ/hour??.png | tail -1 | sed -e 's/.*hour\(..\).png/\1/')

  if [[ $hours -eq 59 ]]; then
      hour=$(($(($(date +%-I) * 5 + $(($(date +%-M) + 3)) / 12)) % 60))
  elif [[ $hours -eq 23 ]]; then
      hour=$(($(date +%-H)))
  else
      hour=$(($(date +%-I)))
  fi
  cd $WCZ && convert -layers flatten bg.jpg $(date +"month%-m.png weekday%u.png day%-d.png hour${hour}.png minute%-M.png second%-S.png") - | feh - --bg-scale
#+END_SRC

#+BEGIN_SRC sh :tangle ~/.xprofile :comments noweb :tangle-mode (identity #o444)
  while true; do nix-shell -p imagemagick --run ~/bin/wallpaperclock; sleep 60; done &
#+END_SRC

** Emacs Mode line

#+BEGIN_SRC emacs-lisp
  ;; (use-package powerline
  ;;   :config (powerline-default-theme))
  (use-package spaceline
    :config (progn
              (require 'spaceline-config)
              (spaceline-emacs-theme)
              (spaceline-helm-mode)))
#+END_SRC

** Notifications

#+BEGIN_SRC emacs-lisp
  (use-package alert
    :commands (alert)
    :init (setq alert-default-style 'notifications))
#+END_SRC

Log the notifications with Sauron

#+BEGIN_SRC emacs-lisp
  (use-package sauron
    :commands (sauron-start)
    :config (progn
              (setq sauron-notifications-urgency-to-priority-plist
                    '(:low 3 :normal 4 :critical 5 :otherwise 3))
              (setq alert-user-configuration (quote ((nil notifications nil))))
              (setq sauron-hide-mode-line t
                    sauron-sticky-frame t)))
#+END_SRC

** Use UTF-8 by default

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)
#+END_SRC

** Font face

I read about Hack.

#+BEGIN_SRC emacs-lisp
  (when (member "Hack" (font-family-list))
    (set-face-attribute 'default nil :font "Hack"))
#+END_SRC

Which I also like for termite, by the way.

#+BEGIN_SRC conf :tangle ~/.config/termite/config :comments noweb :tangle-mode (identity #o444) :mkdirp yes
  [options]
  font = Hack 9
#+END_SRC

Use Symbola for unicode characters

#+BEGIN_SRC emacs-lisp
  (when (member "Symbola" (font-family-list))
    (set-fontset-font t 'unicode "Symbola" nil 'prepend))
#+END_SRC

** Font size

I like smaller fonts.

#+BEGIN_SRC elisp
  (set-face-attribute 'default nil :height 75)
#+END_SRC

** Window management

Use ~ace-window~ to jump to where I want.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . ace-window))
    :config (progn
              (setq aw-scope 'frame
                    aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s) ; I use Dvorak
                    )))
#+END_SRC

Kill side-windows with ~C-c q~

#+BEGIN_SRC emacs-lisp
  ;; Stolen from http://www.lunaryorn.com/posts/the-power-of-display-buffer-alist.html

  (defun joranvar:quit-bottom-side-windows ()
    "Quit bottom side windows of the current frame."
    (interactive)
    (dolist (window (window-at-side-list nil 'bottom))
      (quit-window nil window)))

  (global-set-key (kbd "C-c q") #'joranvar:quit-bottom-side-windows)
#+END_SRC

Toggle-split helps me split the window in the other direction.
Thanks Wilfred (https://www.emacswiki.org/emacs/ToggleWindowSplit).

#+BEGIN_SRC emacs-lisp
  (defun toggle-frame-split ()
    "If the frame is split vertically, split it horizontally or vice versa.
  Assumes that the frame is only split into two."
    (interactive)
    (unless (= (length (window-list)) 2) (error "Can only toggle a frame split in two"))
    (let ((split-vertically-p (window-combined-p)))
      (delete-window) ; closes current window
      (if split-vertically-p
          (split-window-horizontally)
        (split-window-vertically)) ; gives us a split with the other window twice
      (switch-to-buffer nil))) ; restore the original window in this part of the frame

  (global-set-key (kbd "C-x 7") 'toggle-frame-split)
#+END_SRC

** Use pretty unicode characters

#+BEGIN_SRC emacs-lisp
  (use-package pretty-mode
    :init (progn (global-prettify-symbols-mode t)))
#+END_SRC

** Use icons

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :config (progn (unless (file-exists-p "~/.local/share/fonts/all-the-icons.ttf")
                     (all-the-icons-install-fonts))))
  (use-package all-the-icons-dired
    :config (progn
              (add-hook 'dired-mode-hook #'all-the-icons-dired-mode)))
#+END_SRC

