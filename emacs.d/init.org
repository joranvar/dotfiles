#+TITLE: The dotfile root

* Purpose

This file is tangled on Emacs startup, which will result in both more configuration to be loaded by Emacs and dotfiles to serve as configuration for other programs.

* Emacs configuration
:PROPERTIES:
:header-args: :tangle ./init.org.el :comments noweb :tangle-mode (identity #o444)
:END:

** Package preparation

*** Package sources 
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/.emacs.d/elpa"))

  (setq package-archives '(("gnu"          . "http://elpa.gnu.org/packages/")
                           ("melpa-stable" . "http://stable.melpa.org/packages/")
                           ("melpa"        . "http://melpa.org/packages/")
                           ("org"          . "http://orgmode.org/elpa/")))

  (package-initialize)
#+END_SRC

*** ~use-package~

Then, we'll use ~use-package~ to install and configure all others.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+END_SRC

Ensure that a package is installed by default (why would I enter it otherwise?)

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

*** ~paradox~

Finally, we'll switch to using paradox, for its async execution and automatic updating functionalities.

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :config
    (progn
      (setq paradox-execute-asynchronously t)
      (paradox-enable)
      (paradox-refresh-upgradeable-packages)))
#+END_SRC

** Custom settings

They should not be set in the generated ~init.org.el~, but sometimes I want to see what a customization does.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file) (load custom-file))
#+END_SRC

** Basic utils

~dash.el~, ~f.el~ and ~s.el~ cannot be omitted, as they provide very useful tools for emacs-lisp programming.

#+BEGIN_SRC emacs-lisp
  (use-package dash)
  (use-package s)
  (use-package f)
#+END_SRC

*** Async

Add some asyncness, for the sake of less waiting time.

#+BEGIN_SRC emacs-lisp
  (use-package async)
#+END_SRC

** Aesthetics

I want my Emacs to look good.

*** No mouse cruft

Please, use all my screen real estate for information, not for "places to click on".

#+BEGIN_SRC emacs-lisp
  (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
  (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
  (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (fboundp 'tooltip-mode) (tooltip-mode -1) (setq tooltip-use-echo-area t))
  (fringe-mode '(4 . 0))
#+END_SRC

Although, I do have a mouse, and sometimes I use it to focus a window in my window manager.  That's when I like to also focus a window inside Emacs.

#+BEGIN_SRC emacs-lisp
  (setq focus-follows-mouse t
        mouse-autoselect-window t)
#+END_SRC

*** Show me info about my buffer

I want to know where am, and have immediate visual feedback about my text.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (column-number-mode)
  (show-paren-mode)

  (use-package linum
    :config (global-linum-mode))
#+END_SRC

*** Theme to use

This is the theme I will use currently.

#+BEGIN_SRC emacs-lisp
  (use-package leuven-theme
    :config (load-theme 'leuven t))
#+END_SRC

*** Mode line

#+BEGIN_SRC emacs-lisp
  (use-package powerline
    :config (powerline-default-theme))
#+END_SRC

*** Window management

Use ~ace-window~ to jump to where I want.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind (("C-x o" . ace-window))
    :config (progn
              (setq aw-scope 'frame
                    aw-keys '(?a ?o ?e ?u ?i ?d ?h ?t ?n ?s) ; I use Dvorak
                    )))
#+END_SRC

Kill side-windows with ~C-c q~

#+BEGIN_SRC emacs-lisp
  ;; Stolen from http://www.lunaryorn.com/posts/the-power-of-display-buffer-alist.html

  (defun joranvar:quit-bottom-side-windows ()
    "Quit bottom side windows of the current frame."
    (interactive)
    (dolist (window (window-at-side-list nil 'bottom))
      (quit-window nil window)))

  (global-set-key (kbd "C-c q") #'joranvar:quit-bottom-side-windows)
#+END_SRC

** Basic text editing

*** Whitespace pet peeves

Do, please do, remove whitespace from the end of lines, before saving my buffers.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace-cleanup-mode
    :diminish whitespace-mode global-whitespace-mode
    :config (progn
              (setq-default whitespace-style '(face spaces tabs newline
                                                    space-mark tab-mark
                                                    newline-mark
                                                    trailing lines-tail empty
                                                    indentation::space
                                                    space-after-tab::space)
                            whitespace-line-column 160
                            indent-tabs-mode nil
                            require-final-newline t)
              (defadvice align-regexp (around align-regexp-with-spaces activate)
                (let ((indent-tabs-mode nil))
                  ad-do-it))
              (setq-default tab-width 2)
              (global-whitespace-mode)
              (global-whitespace-cleanup-mode)))
#+END_SRC

*** Search and replace

Search and replace with regexes by default, and show me what you're about to do.

#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :bind* (("C-c r" . anzu-query-replace-regexp)
           ("C-c C-r" . anzu-replace-at-cursor-thing)
           ("C-s" . isearch-forward-regexp)
           ("C-r" . isearch-backward-regexp))
    :diminish anzu-mode
    :config (progn
              (global-anzu-mode)
              (define-key isearch-mode-map [remap isearch-query-replace]  #'anzu-isearch-query-replace)
              (define-key isearch-mode-map [remap isearch-query-replace-regexp] #'anzu-isearch-query-replace-regexp)))
#+END_SRC

** Start Emacs as a server

#+BEGIN_SRC emacs-lisp
  (use-package server
    :config (progn
              (unless (server-running-p) (server-start))))
#+END_SRC

** Menus and discovery

*** ~helm~

I've used ~helm~ for quite some time now, and I like the way it works.  Therefore, it's the default menu for everything now.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :bind (("M-x" . helm-M-x)
           ("C-x C-f" . helm-find-files)
           ("M-y" . helm-show-kill-ring)
           ("C-x b" . helm-mini))
    :diminish helm-mode
    :init (progn
            (require 'helm-config)
            (helm-mode 1)
            (helm-autoresize-mode t)))
#+END_SRC

** Projects

Each project is either a version controlled (~magit~!) directory, or some directory I want to be able to browse at once (local repos of files, e.g. videos or pictures).

*** Version control

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands (magit-git-repo-p
               magit-status-internal)
    :bind (("C-c g" . magit-status))
    :config
    (setq magit-commit-arguments (if (eq system-type 'gnu/linux)
                                     '("--gpg-sign")
                                   '(""))
          magit-diff-arguments '("--ignore-space-change"
                                 "--ignore-all-space"
                                 "--no-ext-diff"
                                 "-M"
                                 "-C")
          magit-log-arguments '("--graph"
                                "--color"
                                "--decorate"
                                "--show-signature"
                                "-n256")
          magit-merge-arguments '("--no-ff")
          magit-rebase-arguments '("--autostash")
          magit-diff-refine-hunk t)
    (use-package git-timemachine)
    (when (eq system-type 'windows-nt)
      (setq magit-git-executable "c:/Program Files/Git/bin/git.exe")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :config (progn
              (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
              (global-diff-hl-mode)))
#+END_SRC

*** Navigation

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind (("M-P" . helm-projectile))
    :diminish projectile-mode
    :config (progn
              (projectile-global-mode)
              (setq projectile-indexing-method 'alien
                    projectile-completion-system 'helm
                    ;; projectile-enable-caching t ;; This messes up tramp-sudo, see https://github.com/bbatsov/projectile/issues/835
                    projectile-enable-idle-timer t)
              (use-package helm-ag)
              (use-package helm-projectile
                :config (progn
                          (helm-projectile-on)
                          (setq projectile-switch-project-action (lambda () (if (magit-git-repo-p (projectile-project-root))
                                                                           (magit-status-internal (projectile-project-root))
                                                                         (dired (projectile-project-root)))))))
              (setq magit-repository-directories (mapcar (lambda (dir)
                                                           (substring dir 0 -1))
                                                         (-filter (lambda (project)
                                                                    (file-directory-p (concat project "/.git/")))
                                                                  (projectile-relevant-known-projects)))
                    magit-repository-directories-depth 1)))
#+END_SRC

** Completion

*** ~company~

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish company-mode
    :config (progn
              (global-company-mode)
              (setq company-idle-delay 0.1)))
#+END_SRC

** Programming

*** General stuff

I use flycheck for almost any buffer that can be checked, so enable it everywhere.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config (progn
              (global-flycheck-mode)
              (add-to-list 'display-buffer-alist
                           `(,(rx bos "*Flycheck errors*" eos)
                             (display-buffer-reuse-window
                              display-buffer-in-side-window)
                             (reusable-frames . visible)
                             (side            . bottom)
                             (window-height   . 10)))))
#+END_SRC

I like my parentheses balanced, thank you!

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :config (progn
              (require 'smartparens-config)
              (show-smartparens-global-mode)
              (smartparens-global-strict-mode)
              (sp-use-paredit-bindings)))
#+END_SRC

Also, please indent my code smartly (except for in F#, it does not play nice there)!

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :config (progn
              (global-aggressive-indent-mode)
              (add-to-list 'aggressive-indent-excluded-modes 'org-mode)))
#+END_SRC

*** F#

In F#, I'd like to set the following settings:

#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode
    :config (progn
              (setq fsharp-indent-offset 2)
              (add-to-list 'aggressive-indent-excluded-modes 'fsharp-mode)))
#+END_SRC

*** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs\\'"
    :config (progn
              (require 'haskell-indentation)
              (use-package hlint-refactor
                :config (add-hook 'haskell-mode-hook 'hlint-refactor-mode))
              (use-package company-ghc
                :config (add-to-list 'company-backends 'company-ghc))
              (setq company-ghc-show-info t)
              (add-to-list 'aggressive-indent-excluded-modes 'haskell-mode)))
#+END_SRC

In Haskell, use `dante`.

#+BEGIN_SRC emacs-lisp
  (use-package dante
    :commands 'dante-mode
    :init (progn
            (add-hook 'haskell-mode-hook 'dante-mode)
            (setq-default dante-repl-command-line-methods-alist
                          `(
                            (styx .
                                  ,(lambda (root)
                                     (dante-repl-by-file root "styx.yaml"
                                                         '("styx" "repl"))))
                            (nix-new .
                                     ,(lambda (root)
                                        (dante-repl-by-file
                                         (projectile-project-root)
                                         "shell.nix"
                                         `("nix-shell" "--run" "cabal new-repl"
                                           ,(concat (projectile-project-root) "/shell.nix")))))
                            (stack .
                                   ,(lambda (root)
                                      (dante-repl-by-file root "stack.yaml"
                                                          '("stack" "repl"))))
                            (bare  . ,(lambda (_) '("cabal" "repl")))))))
#+END_SRC

*** Yaml

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'"
    :config (add-to-list 'aggressive-indent-excluded-modes 'yaml-mode))
#+END_SRC

** Mail configuration

I used to check mail with Gnus, directly from the imap-server (in the Exchange case, from davmail), but the Gnus/davmail combination is quite slow, and when checking mail, freezes Emacs a bit.
After reading http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/, I decided to setup a different configuration, and use offlineimap.
Reading https://nakkaya.com/2010/04/10/using-offlineimap-with-gnus/ after that, I decided to skip the mu4e, and use the nnmaildir backend in Gnus.
This backend, however, needs a script to be run for syncing the flags with a "regular" Maildir backend.

*** Flag syncing script
:PROPERTIES:
:header-args: :tangle ~/sync_nnmaildir :comments noweb :tangle-mode (identity #o555) :shebang "#!/usr/bin/env perl"
:END:

This script was downloaded (and adjusted a tiny bit) from http://groups.google.com/group/linux.debian.user/msg/7594165a2b6d1c49.

#+BEGIN_SRC perl
  # Maildir flags are:
  #         D (draft)
  #         F (flagged)
  #         R (replied)
  #         S (seen)
  #         T (trashed)
  # and must occur in ASCII order.
  #
  # flagmatchre = re.compile(':.*2,([A-Z]+)')
  #
  # filename:2,F   => .nnmaildir/marks/tick/filename
  # filename:2,R   => .nnmaildir/marks/reply/filename
  # filename:2,S   => .nnmaildir/marks/read/filename

  use strict;
  use File::Basename;
  use Getopt::Long;
  $Getopt::Long::ignorecase = 0;

  my $from_gnus = 0;
  my $from_maildir = 0;
  my $dir = "~/Maildir";
  GetOptions('-g' => \$from_gnus,
             '-m' => \$from_maildir,
             '-d=s' => \$dir);

  if (! ($from_gnus ^ $from_maildir)) {
      die "Usage: sync_nnmaildir -g [-f]\n   or: sync_nnmaildir -m [-v -f]\n";
  }

  for (glob "$dir/*") {
      my $mb = $_;
      mkdir "$mb/.nnmaildir";
      mkdir "$mb/.nnmaildir/marks";

      for (glob "$mb/cur/*") {
          my $file = $_;

          /(.*)\/cur\/(.*?):.*2,(.*)$/;
          my $path = $1;
          my $message = $2;
          my $flags = $3;

          if ($from_maildir) {
              # Sync ticked flags
              if ($flags =~ /F/) {
                  mkdir "$path/.nnmaildir/marks/tick";
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir ticks\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/tick/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir ticks\n";
              }

              # Sync replied flags
              if ($flags =~ /R/) {
                  mkdir "$path/.nnmaildir/marks/reply";
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir replies\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/reply/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir replies\n";
              }

              # Sync read flags
              if ($flags =~ /S/) {
                  mkdir "$path/.nnmaildir/marks/read";
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  link "$file","$dst"
                      and print "Added mail in $mb to nnmaildir seen\n";
              } else {
                  my $dst = "$path/.nnmaildir/marks/read/$message";
                  unlink "$dst"
                      and print "Removed mail in $mb from nnmaildir seen\n";
              }
          } elsif ($from_gnus) {
              my $new_flags = '';

              if (-e "$path/.nnmaildir/marks/tick/$message") {
                  $new_flags = $new_flags . 'F';
              }
              if (-e "$path/.nnmaildir/marks/reply/$message") {
                  $new_flags = $new_flags . 'R';
              }
              if (-e "$path/.nnmaildir/marks/read/$message") {
                  $new_flags = $new_flags . 'S';
              }

              if ($new_flags ne $flags) {
                  rename "$file", "$path/cur/$message:2,$new_flags"
                      and print "Marked mail in $mb as $new_flags\n";
              }
          }
      }
  }

#+END_SRC

*** Offline imap
:PROPERTIES:
:header-args: :tangle ~/.offlineimaprc :comments noweb :tangle-mode (identity #o444)
:END:

#+BEGIN_SRC conf
  [general]
  accounts = Gmail, Exchange
  maxsyncaccounts = 2
  pythonfile = ~/.offlineimap.py

  [Account Gmail]
  localrepository = LocalGmail
  remoterepository = RemoteGmail
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g
  status_backend = sqlite

  [Repository LocalGmail]
  type = Maildir
  localfolders = ~/Maildir/Gmail

  [Repository RemoteGmail]
  type = Gmail
  maxconnections = 2
  remoteuser = bart.post@gmail.com
  remotepasseval = get_password_emacs("gmail", "imaps")
  folderfilter = lambda foldername: foldername not in ['[Gmail]/All Mail', '[Gmail]/Important']
  sslcacertfile = /etc/ssl/certs/ca-certificates.crt

  # These are effectively the same as the above
  [Account Exchange]
  localrepository = LocalExchange
  remoterepository = RemoteExchange
  autorefresh = 5
  quick = 10
  postsynchook = ~/sync_nnmaildir -m
  presynchook = ~/sync_nnmaildir -g
  status_backend = sqlite

  [Repository LocalExchange]
  type = Maildir
  localfolders = ~/Maildir/Exchange

  # This uses davmail
  [Repository RemoteExchange]
  type = IMAP
  maxconnections = 2
  remoteuser = bart.post@cgm.com
  remotehost = localhost
  remotepasseval = get_password_emacs("localhost", "1143")
  remoteport = 1143
  ssl = no
  sync_deletes = no

  sslcacertfile = /etc/ssl/certs/ca-certificates.crt
#+END_SRC

*** Password management with .authinfo.gpg

This python script will be used to get the credentials.

#+BEGIN_SRC python :tangle ~/.offlineimap.py :comments noweb :tangle-mode (identity #o444)
  import subprocess
  def get_output(cmd):
    # Bunch of boilerplate to catch the output of a command:
    pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (output, errout) = pipe.communicate()
    assert pipe.returncode == 0 and not errout
    return output
  def get_password_emacs(host, port):
    cmd = "emacsclient --eval '(offlineimap-get-password \"%s\" \"%s\")'" % (host,port)
    return get_output(cmd).strip().lstrip('"').rstrip('"')
#+END_SRC

And this is the code that will be used to decrypt the authinfo.

#+BEGIN_SRC emacs-lisp
  (use-package offlineimap
    :config (progn
              (setq auth-sources (list "~/.authinfo.gpg"))
              (defun offlineimap-get-password (host port)
                (let ((netrc (nth 0 (auth-source-search
                                     :host host
                                     :port port))))
                  (when netrc (let ((secret (plist-get netrc :secret)))
                                (if (functionp secret)
                                    (funcall secret)
                                  secret)))))))
#+END_SRC

*** Gnus

Gnus will be used to read the mail that was pulled over here.

#+BEGIN_SRC emacs-lisp
  (use-package gnus
    :config (progn
              (setq gnus-select-method '(nnmaildir "GMail"
                                                   (directory "~/Maildir/Gmail")
                                                   (directory-files nnheader-directory-files-safe)
                                                   (get-new-mail nil))
                    gnus-secondary-select-methods '((nnmaildir "Exchange"
                                                               (directory "~/Maildir/Exchange")
                                                               (directory-files nnheader-directory-files-safe)
                                                               (get-new-mail nil)))
                    mm-discouraged-alternatives '("text/html" "text/richtext") ;; Prefer text/plain
                    gnus-decay-scores t
                    gnus-use-adaptive-scoring t)
              (when window-system
                (setq gnus-sum-thread-tree-indent "  ")
                (setq gnus-sum-thread-tree-root "● ")
                (setq gnus-sum-thread-tree-false-root "◯ ")
                (setq gnus-sum-thread-tree-single-indent "◎ ")
                (setq gnus-sum-thread-tree-vertical        "│")
                (setq gnus-sum-thread-tree-leaf-with-other "├─► ")
                (setq gnus-sum-thread-tree-single-leaf     "╰─► "))
              (setq-default gnus-summary-line-format "%U%R%z %(%&user-date;  %-15,15f  %B%s%)\n"
                            gnus-user-date-format-alist '((t . "%Y-%m-%d %H:%M"))
                            gnus-summary-thread-gathering-function 'gnus-gather-threads-by-subject
                            gnus-thread-sort-functions '(gnus-thread-sort-by-number (not gnus-thread-sort-by-total-score))
                            gnus-subthread-sort-functions '(gnus-sort-thread-by-number))
              (add-hook 'gnus-group-mode-hook 'gnus-topic-mode) ;; Show me topics
              (add-hook 'gnus-startup-hook (lambda () (gnus-demon-add-handler 'gnus-demon-scan-news 1 t)))))
#+END_SRC

*** GPG for mails

#+BEGIN_SRC emacs-lisp
  (use-package epg
    :config (progn
              (setq mml2015-use 'epg

                    mml2015-verbose t
                    epg-user-id "9BD68A49AB3D8E4D"
                    mml2015-encrypt-to-self t
                    mml2015-always-trust nil
                    mml2015-cache-passphrase t
                    mml2015-passphrase-cache-expiry '36000
                    mml2015-sign-with-sender t

                    gnus-message-replyencrypt t
                    gnus-message-replysign t
                    gnus-message-replysignencrypted t
                    gnus-treat-x-pgp-sig t

                    ;; mm-sign-option 'guided
                    ;; mm-encrypt-option 'guided
                    mm-verify-option 'always
                    mm-decrypt-option 'always
                    gnus-buttonized-mime-types '("multipart/alternative" "multipart/encrypted" "multipart/signed"))
              (add-hook 'gnus-message-setup-hook (lambda () (mml-secure-message-sign)))))
#+END_SRC

*** Sending mail

When sending a mail, it should reflect who I want to send it as (from my work mail, or personal).

#+BEGIN_SRC emacs-lisp
  (use-package smtpmail
    :config (progn
              (require 'message)
              (setq gnus-posting-styles
                    '((".*"
                       (signature "")
                       (address "bart.post@gmail.com")
                       ("X-Message-SMTP-Method" "smtp smtp.gmail.com 587 bart.post@gmail.com")
                       (eval (set (make-local-variable 'message-cite-style) message-cite-style-gmail)))
                      ("Exchange"
                       (signature "")
                       (address "bart.post@cgm.com")
                       ("X-Message-SMTP-Method" "smtp localhost 1025 bart.post@cgm.com")
                       (eval (set (make-local-variable 'message-cite-style) message-cite-style-outlook)))))
              (setq smtpmail-stream-type nil
                    mail-user-agent 'message-user-agent
                    smtpmail-smtp-service 587
                    message-send-mail-function 'smtpmail-send-it
                    smtpmail-default-smtp-server "smtp.gmail.com"
                    send-mail-function 'smtpmail-send-it)))
#+END_SRC

Also, I want to be able to compose mail in org-mode and send it as html.

#+BEGIN_SRC emacs-lisp
  (use-package org-mime
    :config (progn
              (add-hook 'message-mode-hook
                        (lambda ()
                          (orgstruct-mode)
                          (local-set-key "\C-co" (lambda ()
                                                    (interactive)
                                                    (save-excursion
                                                      (message-goto-body)
                                                      (when (looking-at "<#secure.*>") (forward-line 1))
                                                      (set-mark-command nil)
                                                      (insert "#+OPTIONS: toc:nil ^:nil\n")
                                                      (goto-char (point-max))
                                                      (org-mime-htmlize nil))))))
              (add-hook 'org-mode-hook
                        (lambda () (local-set-key "\C-co" 'org-mime-org-buffer-htmlize)))))

#+END_SRC

** Browsing

Use conkeror by default.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-generic-program (executable-find "conkeror")
        browse-url-browser-function 'browse-url-generic)
#+END_SRC

Use ~moz-repl~ to communicate with conkeror.

#+BEGIN_SRC emacs-lisp
  (use-package moz
    :commands moz-minor-mode
    :config (progn
              (add-hook 'javascript-mode-hook (lambda () (moz-minor-mode 1)))))
#+END_SRC

** Literate programming

Oh boy, org-babel is so nice!

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :config (progn
              (use-package ob-http)
              (org-babel-do-load-languages 'org-babel-load-languages '((sql . t)
                                                                       (shell . t)
                                                                       (http . t)))))
#+END_SRC

** Agenda management

#+BEGIN_SRC emacs-lisp
  (use-package org
    :bind (("C-c a" . org-agenda))
    :config (progn
              (setq org-use-sub-superscripts '{}
                    org-pretty-entities t
                    org-fontify-emphasized-text t
                    org-adapt-indentation nil
                    org-hide-leading-stars t
                    org-ellipsis "↷"
                    org-catch-invisible-edits 'error)))
#+END_SRC
